package com.typosbro.multilevel

import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.util.Log
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.activity.viewModels
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.app.AppCompatDelegate
import androidx.compose.runtime.LaunchedEffect
import androidx.core.os.LocaleListCompat
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.typosbro.multilevel.navigation.AppNavigation
import com.typosbro.multilevel.ui.theme.MultilevelTheme
import com.typosbro.multilevel.ui.viewmodels.AuthViewModel
import com.typosbro.multilevel.ui.viewmodels.SettingsViewModel
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : AppCompatActivity() {

    private val settingsViewModel: SettingsViewModel by viewModels()

    // Get a reference to the AuthViewModel to call the verification function
    private val authViewModel: AuthViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        setContent {

            val isDarkTheme =
                settingsViewModel.isDarkTheme.collectAsStateWithLifecycle(initialValue = false).value
            val languageCode =
                settingsViewModel.currentLanguageCode.collectAsStateWithLifecycle().value


            LaunchedEffect(languageCode) {
                if (!languageCode.isNullOrEmpty()) {
                    val appLocale = LocaleListCompat.forLanguageTags(languageCode)
                    AppCompatDelegate.setApplicationLocales(appLocale)
                }
            }

            MultilevelTheme(darkTheme = isDarkTheme) {
                AppNavigation()
            }
        }

        // Handle the deep link if the app was launched by it
        handleDeepLink(intent)
    }


    // --- CORRECTED onNewIntent ---
    // The `intent` parameter is non-nullable in the correct override signature.
    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        // Set the new intent as the activity's current intent
        setIntent(intent)
        // Handle the deep link from the new intent
        handleDeepLink(intent)
    }

    // --- CORRECTED handleDeepLink ---
    // This function can now safely accept a non-nullable Intent,
    // although keeping it nullable is fine for the onCreate case.
    private fun handleDeepLink(intent: Intent?) {
        val data: Uri? = intent?.data
        if (data != null && data.scheme == "multilevelapp" && data.host == "login") {
            val token = data.getQueryParameter("token")
            if (!token.isNullOrBlank()) {
                Log.d("DeepLink", "Received one-time token: $token")
                // Call the ViewModel function to verify the token.
                // The ViewModel will handle the API call and update the session state,
                // and the UI will react automatically.
                authViewModel.verifyOneTimeToken(token)
            }
        }
    }
}
// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/local/SessionManager.kt
package com.typosbro.multilevel.data.local

import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SessionManager @Inject constructor(private val tokenManager: TokenManager) {

    // This StateFlow is the new single source of truth for the auth token.
    private val _tokenFlow = MutableStateFlow<String?>(null)
    val tokenFlow = _tokenFlow.asStateFlow()

    private val _logoutEvents = MutableSharedFlow<Unit>()
    val logoutEvents = _logoutEvents.asSharedFlow()

    init {
        // When the app starts, load the token from storage into our StateFlow.
        _tokenFlow.value = tokenManager.getToken()
    }

    /**
     * Call this after a successful login to update the session state.
     */
    fun updateToken(newToken: String) {
        tokenManager.saveToken(newToken)
        _tokenFlow.value = newToken
    }

    /**
     * Call this to log out. It clears the token from storage and updates the session state.
     */
    suspend fun logout() {
        tokenManager.clearToken()
        _tokenFlow.value = null
        // We can still emit this event for any explicit side-effects if needed,
        // but the tokenFlow becoming null will be the primary trigger for navigation.
        _logoutEvents.emit(Unit)
    }
}
// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/local/TokenManager.kt
package com.typosbro.multilevel.data.local

import android.content.Context
import android.content.SharedPreferences
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey

// This class is now just a simple, direct wrapper around EncryptedSharedPreferences.
class TokenManager(context: Context) {

    private val masterKey = MasterKey.Builder(context)
        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
        .build()

    private val sharedPreferences: SharedPreferences = EncryptedSharedPreferences.create(
        context,
        "auth_prefs",
        masterKey,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )

    companion object {
        private const val AUTH_TOKEN_KEY = "auth_token"
    }

    fun saveToken(token: String) {
        sharedPreferences.edit().putString(AUTH_TOKEN_KEY, token).apply()
    }

    fun getToken(): String? {
        return sharedPreferences.getString(AUTH_TOKEN_KEY, null)
    }

    fun clearToken() {
        sharedPreferences.edit().remove(AUTH_TOKEN_KEY).apply()
    }

    fun hasToken(): Boolean {
        return getToken() != null
    }

    // --- REMOVED THE tokenFlow callbackFlow ---
}
// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/local/WordDao.kt
package com.typosbro.multilevel.data.local

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import kotlinx.coroutines.flow.Flow

@Dao
interface WordDao {
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insertAll(words: List<WordEntity>)

    @Update
    suspend fun update(word: WordEntity)

    // --- REVISED: Get due words with optional filters ---
    @Query(
        "SELECT * FROM words WHERE nextReviewTimestamp <= :currentTime " +
                "AND (:level IS NULL OR cefrLevel = :level) " +
                "AND (:topic IS NULL OR topic = :topic) " +
                "ORDER BY nextReviewTimestamp ASC"
    )
    fun getDueWords(
        currentTime: Long,
        level: String? = null,
        topic: String? = null
    ): Flow<List<WordEntity>>

    // --- Count queries for the global stats ---
    @Query("SELECT COUNT(id) FROM words WHERE nextReviewTimestamp <= :currentTime")
    fun getDueWordsCount(currentTime: Long): Flow<Int>

    @Query("SELECT COUNT(id) FROM words WHERE repetitions = 0")
    fun getNewWordsCount(): Flow<Int>

    @Query("SELECT COUNT(id) FROM words")
    fun getTotalWordsCount(): Flow<Int>

    // --- Count queries for specific levels ---

    @Query("SELECT COUNT(id) FROM words WHERE cefrLevel = :level AND nextReviewTimestamp <= :currentTime")
    suspend fun countDueWordsInLevel(level: String, currentTime: Long): Int

    @Query("SELECT COUNT(id) FROM words WHERE cefrLevel = :level AND repetitions = 0")
    suspend fun countNewWordsInLevel(level: String): Int

    @Query("SELECT COUNT(id) FROM words WHERE cefrLevel = :level")
    suspend fun countTotalWordsInLevel(level: String): Int

    // --- Count queries for specific topics ---
    @Query("SELECT COUNT(id) FROM words WHERE cefrLevel = :level AND topic = :topic AND nextReviewTimestamp <= :currentTime")
    suspend fun countDueWordsInTopic(level: String, topic: String, currentTime: Long): Int

    @Query("SELECT COUNT(id) FROM words WHERE cefrLevel = :level AND topic = :topic AND repetitions = 0")
    suspend fun countNewWordsInTopic(level: String, topic: String): Int

    @Query("SELECT COUNT(id) FROM words WHERE cefrLevel = :level AND topic = :topic")
    suspend fun countTotalWordsInTopic(level: String, topic: String): Int

    // Other functions (delete, etc.) remain the same
    @Query("DELETE FROM words WHERE cefrLevel = :level AND topic = :topic")
    suspend fun deleteByTopic(level: String, topic: String)

    @Query("DELETE FROM words WHERE cefrLevel = :level")
    suspend fun deleteByLevel(level: String)
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/local/WordDatabase.kt
package com.typosbro.multilevel.data.local

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase

@Database(entities = [WordEntity::class], version = 1, exportSchema = false)
abstract class WordDatabase : RoomDatabase() {

    abstract fun wordDao(): WordDao

    companion object {
        @Volatile
        private var INSTANCE: WordDatabase? = null

        fun getDatabase(context: Context): WordDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    WordDatabase::class.java,
                    "word_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/local/WordEntity.kt
package com.typosbro.multilevel.data.local

import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "words",
    indices = [Index(value = ["word"], unique = true)]
)
data class WordEntity(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    val word: String,
    val translation: String,
    val example1: String?,
    val example1Translation: String?,
    val example2: String?,
    val example2Translation: String?,
    val cefrLevel: String,
    val topic: String,

    // --- REVISED: Spaced Repetition System (SRS) Fields for SM-2 ---
    var repetitions: Int = 0,           // n: Number of successful (q >= 3) repetitions.
    var easinessFactor: Float = 2.5f,   // EF: The easiness factor, starts at 2.5.
    var interval: Int = 0,              // The last calculated interval in days.
    var nextReviewTimestamp: Long = 0L
)
package com.typosbro.multilevel.data.preferences

import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.stringPreferencesKey
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
// import java.util.Locale // No longer needed here
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class LanguageRepository @Inject constructor(
    private val dataStore: DataStore<Preferences>
) {
    private val selectedLanguageKey = stringPreferencesKey("selected_language_code")

    /**
     * A Flow that emits the current language code (e.g., "en", "ru")
     * or null if no preference has been set yet.
     */
    val languageCode: Flow<String?> = dataStore.data // Change to Flow<String?>
        .map { preferences ->
            // This will emit the saved code, or null if the key doesn't exist.
            preferences[selectedLanguageKey]
        }

    suspend fun setLanguage(languageCode: String) {
        dataStore.edit { settings ->
            settings[selectedLanguageKey] = languageCode
        }
    }
}

package com.typosbro.multilevel.data.preferences

// import android.content.Context // NO LONGER NEEDED
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.booleanPreferencesKey
import androidx.datastore.preferences.core.edit
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton


@Singleton
class ThemeRepository @Inject constructor(
    private val dataStore: DataStore<Preferences>
) {
    private val isDarkThemeKey = booleanPreferencesKey("is_dark_theme")

    val isDarkTheme: Flow<Boolean> = dataStore.data // Use the injected dataStore
        .map { preferences ->
            preferences[isDarkThemeKey] == true
        }

    suspend fun setTheme(isDark: Boolean) {
        dataStore.edit { settings -> // Use the injected dataStore
            settings[isDarkThemeKey] = isDark
        }
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/remote/interceptors/AuthInterceptor.kt
package com.typosbro.multilevel.data.remote.interceptors

import com.typosbro.multilevel.data.local.SessionManager
import kotlinx.coroutines.runBlocking
import okhttp3.Interceptor
import okhttp3.Response
import javax.inject.Inject

class AuthInterceptor @Inject constructor(
    private val sessionManager: SessionManager
) : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        // --- THIS IS THE CORRECTED LINE ---
        // Get the current token directly from the StateFlow's value property.
        val token = sessionManager.tokenFlow.value

        val originalRequest = chain.request()
        val path = originalRequest.url.encodedPath

        // Define which routes are "public" and should NOT receive a token.
        val isPublicRoute = path.contains("/auth/login") || path.contains("/auth/register")

        val requestBuilder = originalRequest.newBuilder()

        // If a token exists AND it's NOT a public route, add the Authorization header.
        if (token != null && !isPublicRoute) {
            requestBuilder.addHeader("Authorization", "Bearer $token")
        }

        val request = requestBuilder.build()
        val response = chain.proceed(request)

        // If the server rejects our token with 401, trigger a global logout.
        // This check should only matter for non-public routes that we tried to authorize.
        if (response.code == 401 && !isPublicRoute) {
            runBlocking {
                sessionManager.logout()
            }
        }

        return response
    }
}

package com.typosbro.multilevel.data.remote.models

import com.google.gson.annotations.SerializedName

// --- Auth Response ---
// email and firstName are now nullable to handle all provider types.
data class AuthResponse(
    @SerializedName("_id") val id: String,
    @SerializedName("email") val email: String?,
    @SerializedName("firstName") val firstName: String?,
    @SerializedName("token") val token: String
)

// --- Social Auth Requests ---
data class GoogleSignInRequest(val idToken: String)
data class OneTimeTokenRequest(val oneTimeToken: String)


// --- User Profile Response ---
// This model should also reflect that some fields can be null.
data class UserProfileResponse(
    @SerializedName("_id") val id: String,
    @SerializedName("email") val email: String?,
    @SerializedName("firstName") val firstName: String?,
    @SerializedName("telegramId") val telegramId: Long?,
    @SerializedName("username") val username: String?, // Telegram username
    @SerializedName("authProvider") val authProvider: String,
    @SerializedName("createdAt") val createdAt: String
)

package com.typosbro.multilevel.data.remote.models

/**
 * A generic response model for API calls that return a simple success message.
 * Used for actions like deleting or updating items where no specific data body is returned.
 */
data class GenericSuccessResponse(val message: String)

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/remote/models/ExamModel.kt
package com.typosbro.multilevel.data.remote.models

import com.google.gson.annotations.SerializedName

/**
 * Represents a single entry in the conversation transcript.
 * Used for sending the full transcript for final analysis.
 */
data class TranscriptEntry(
    @SerializedName("speaker") val speaker: String, // "Examiner" or "User"
    @SerializedName("text") val text: String
)

/**
 * The request body sent to the server to get the next examiner question/prompt.
 */
data class ExamStepRequest(
    @SerializedName("part") val part: Int,
    @SerializedName("userInput") val userInput: String?,
    @SerializedName("transcriptContext") val transcriptContext: String,
    @SerializedName("questionCountInPart") val questionCountInPart: Int
)
/**
 * The response from the server for each step of the exam.
 */
data class ExamStepResponse(
    @SerializedName("examiner_line") val examinerLine: String,
    @SerializedName("next_part") val nextPart: Int, // The part we are now in (server is source of truth)
    @SerializedName("cue_card") val cueCard: CueCard?, // Nullable, only present for Part 2
    @SerializedName("is_final_question") val isFinalQuestion: Boolean = false,
    @SerializedName("input_ids") val inputIds: List<Int>? // For client-side TTS
)

/**
 * Represents the Part 2 Cue Card topic and points.
 */
data class CueCard(
    @SerializedName("topic") val topic: String,
    @SerializedName("points") val points: List<String>
)

/**
 * The request body sent to the server to begin the final analysis.
 * Contains the complete, structured transcript.
 */
data class AnalyzeExamRequest(
    @SerializedName("transcript") val transcript: List<TranscriptEntry>
)

/**
 * The immediate response after requesting analysis.
 * Since analysis can take time, the server just returns an ID
 * that can be used later to fetch the full results.
 */
data class AnalyzeExamResponse(
    @SerializedName("resultId") val resultId: String
)

package com.typosbro.multilevel.data.remote.models

import com.google.gson.annotations.SerializedName

// --- Data models for the entire exam package ---

data class MultilevelExamResponse(
    @SerializedName("part1_1") val part1_1: List<Part1_1Question>,
    @SerializedName("part1_2") val part1_2: Part1_2Set,
    @SerializedName("part2") val part2: Part2Set,
    @SerializedName("part3") val part3: Part3Topic
)

data class Part1_1Question(
    @SerializedName("_id") val id: String,
    @SerializedName("questionText") val questionText: String,
    @SerializedName("audioUrl") val audioUrl: String
)

data class Part1_2Set(
    @SerializedName("_id") val id: String,
    @SerializedName("image1Url") val image1Url: String,
    @SerializedName("image2Url") val image2Url: String,
    @SerializedName("questions") val questions: List<QuestionAudio>
)

data class Part2Set(
    @SerializedName("_id") val id: String,
    @SerializedName("imageUrl") val imageUrl: String,
    @SerializedName("questions") val questions: List<QuestionAudio>
)

data class Part3Topic(
    @SerializedName("_id") val id: String,
    @SerializedName("topic") val topic: String,
    @SerializedName("forPoints") val forPoints: List<String>,
    @SerializedName("againstPoints") val againstPoints: List<String>
)

data class QuestionAudio(
    @SerializedName("text") val text: String,
    @SerializedName("audioUrl") val audioUrl: String
)

// --- Models for sending the final analysis request ---

data class MultilevelAnalyzeRequest(
    val transcript: List<TranscriptEntry>, // Can reuse from IELTS models
    val examContentIds: ExamContentIds,
    val practicePart: String? = null
)

data class ExamContentIds(
    @SerializedName("part1_1") val part1_1: List<String>,
    @SerializedName("part1_2") val part1_2: String,
    @SerializedName("part2") val part2: String,
    @SerializedName("part3") val part3: String
)

// --- Models for displaying the multilevel results ---

data class MultilevelExamResultResponse(
    @SerializedName("_id") val id: String,
    @SerializedName("userId") val userId: String,
    @SerializedName("totalScore") val totalScore: Int,
    @SerializedName("feedbackBreakdown") val feedbackBreakdown: List<FeedbackBreakdown>,
    @SerializedName("transcript") val transcript: List<TranscriptEntry>,
    @SerializedName("createdAt") val createdAt: String
)

data class FeedbackBreakdown(
    @SerializedName("part") val part: String,
    @SerializedName("score") val score: Int,
    @SerializedName("feedback") val feedback: String
)

data class MultilevelExamHistorySummaryResponse(
    val history: List<MultilevelExamResultSummary>
)

// UPDATED: Added practicePart to distinguish between full exams and part practices
data class MultilevelExamResultSummary(
    val id: String,
    val examDate: Long,
    val totalScore: Int,
    val practicePart: String // e.g., "FULL", "P1_1", "P2", etc.
)

package com.typosbro.multilevel.data.remote.models

import org.json.JSONObject
import retrofit2.Response

/**
 * A reusable sealed class for wrapping repository responses.
 * It clearly defines a success state with data or an error state with a message.
 */
sealed class RepositoryResult<out T> {
    data class Success<out T>(val data: T) : RepositoryResult<T>()
    data class Error(val message: String, val code: Int? = null) : RepositoryResult<Nothing>()
}

/**
 * A reusable helper function to safely execute API calls and wrap the response
 * in our custom RepositoryResult class. It handles success, API errors, and
 * network/parsing exceptions.
 */
suspend inline fun <T> safeApiCall(crossinline apiCall: suspend () -> Response<T>): RepositoryResult<T> {
    return try {
        val response = apiCall()
        if (response.isSuccessful) {
            response.body()?.let { RepositoryResult.Success(it) }
                ?: RepositoryResult.Error("API call successful but response body was null", response.code())
        } else {
            // Try to parse the specific error message from the backend
            val errorBody = response.errorBody()?.string()
            val errorMessage = try {
                errorBody?.let { JSONObject(it).getString("message") } ?: "Unknown error"
            } catch (e: Exception) {
                response.message() ?: "Unknown error" // Fallback to HTTP message
            }
            RepositoryResult.Error(errorMessage, response.code())
        }
    } catch (e: Exception) {
        RepositoryResult.Error("Network error or exception: ${e.message ?: "Unknown exception"}")
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/remote/models/ResultModel.kt

package com.typosbro.multilevel.data.remote.models

import com.google.gson.annotations.SerializedName

data class ExamHistorySummaryResponse(
    @SerializedName("history") val history: List<ExamResultSummary>
)



/**
 * A summary of a single past exam result, used in the ProgressScreen list.
 */
data class ExamResultSummary(
    @SerializedName("id") val id: String,
    @SerializedName("examDate") val examDate: Long,
    @SerializedName("overallBand") val overallBand: Double
)

/**
 * The full, detailed response for a single exam result.
 * This is the primary model for the Exam Result Details screen.
 */
data class ExamResultResponse(
    @SerializedName("_id") val id: String,
    @SerializedName("userId") val userId: String,
    @SerializedName("overallBand") val overallBand: Double,
    @SerializedName("criteria") val criteria: List<Criterion>,
    @SerializedName("transcript") val transcript: List<TranscriptEntry>,
    @SerializedName("createdAt") val createdAt: String
)

/**
 * Represents the feedback for one of the four IELTS criteria.
 */
data class Criterion(
    @SerializedName("criterionName") val criterionName: String,
    @SerializedName("bandScore") val bandScore: Double,
    @SerializedName("feedback") val feedback: String,
    @SerializedName("examples") val examples: List<FeedbackExample>? // Nullable for safety
)

/**
 * Represents a specific example of feedback, with a user quote and a suggestion.
 */
data class FeedbackExample(
    @SerializedName("userQuote") val userQuote: String,
    @SerializedName("suggestion") val suggestion: String,
    @SerializedName("type") val type: String // e.g., "Fluency", "Vocabulary"
)

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/remote/models/StreamEventsModel.kt
package com.typosbro.multilevel.data.remote.models

// --- Data classes for parsing JSON from SSE events ---
// These are shared between freestyle chat and exam streams

data class TextChunk(val text: String)
data class InputIdsChunk(val sentence: String, val input_ids: List<Int>)
data class StreamEnd(val message: String) // For simple stream end
data class PreprocessWarning(val message: String, val sentenceText: String?)
data class PreprocessError(val message: String, val sentenceText: String?)
data class StreamError(val message: String, val details: String?)

// --- Sealed class for FREESTYLE CHAT events ---

sealed class ChatStreamEvent {
    data class TextChunk(val text: String) : ChatStreamEvent()
    data class InputIdsChunk(val sentence: String, val ids: List<Int>) : ChatStreamEvent()
    data class StreamEnd(val message: String) : ChatStreamEvent()
    data class PreprocessWarning(val message: String, val sentenceText: String?) : ChatStreamEvent()
    data class PreprocessError(val message: String, val sentenceText: String?) : ChatStreamEvent()
    data class StreamError(val message: String, val details: String?) : ChatStreamEvent()
}


// --- Sealed class for EXAM events ---

// Data class specific to the end of an EXAM stream
data class ExamStreamEndData(
    val next_part: Int,
    val cue_card: CueCard?,
    val is_final_question: Boolean
)

sealed class ExamEvent {
    data class TextChunk(val text: String) : ExamEvent()
    data class InputIdsChunk(val sentence: String, val ids: List<Int>) : ExamEvent()
    data class StreamEnd(val endData: ExamStreamEndData) : ExamEvent()
    data class StreamError(val message: String) : ExamEvent()
}

package com.typosbro.multilevel.data.remote.models

import com.google.gson.annotations.SerializedName

/**
 * Represents a single word entry fetched from the backend API.
 * This is used for the word discovery feature.
 */
data class ApiWord(
    @SerializedName("_id") val id: String,
    @SerializedName("word") val word: String,
    @SerializedName("cefrLevel") val cefrLevel: String,
    @SerializedName("topic") val topic: String,
    @SerializedName("translation") val translation: String,
    @SerializedName("example1") val example1: String?,
    @SerializedName("example1Translation") val example1Translation: String?,
    @SerializedName("example2") val example2: String?,
    @SerializedName("example2Translation") val example2Translation: String?
)

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/remote/ApiService.kt
package com.typosbro.multilevel.data.remote

import com.typosbro.multilevel.data.remote.models.AnalyzeExamRequest
import com.typosbro.multilevel.data.remote.models.AnalyzeExamResponse
import com.typosbro.multilevel.data.remote.models.ApiWord
import com.typosbro.multilevel.data.remote.models.AuthResponse
import com.typosbro.multilevel.data.remote.models.ExamHistorySummaryResponse
import com.typosbro.multilevel.data.remote.models.ExamResultResponse
import com.typosbro.multilevel.data.remote.models.ExamStepRequest
import com.typosbro.multilevel.data.remote.models.ExamStepResponse
import com.typosbro.multilevel.data.remote.models.GenericSuccessResponse
import com.typosbro.multilevel.data.remote.models.GoogleSignInRequest
import com.typosbro.multilevel.data.remote.models.MultilevelAnalyzeRequest
import com.typosbro.multilevel.data.remote.models.MultilevelExamHistorySummaryResponse
import com.typosbro.multilevel.data.remote.models.MultilevelExamResponse
import com.typosbro.multilevel.data.remote.models.MultilevelExamResultResponse
import com.typosbro.multilevel.data.remote.models.OneTimeTokenRequest
import com.typosbro.multilevel.data.remote.models.UserProfileResponse
import retrofit2.Response
import retrofit2.http.Body
import retrofit2.http.DELETE
import retrofit2.http.GET
import retrofit2.http.POST
import retrofit2.http.Path
import retrofit2.http.Query


interface ApiService {

    // --- Social Auth Endpoints ---
    @POST("auth/google-signin")
    suspend fun googleSignIn(@Body request: GoogleSignInRequest): Response<AuthResponse>

    // NEW: Endpoint for verifying the deep link token
    @POST("auth/verify-telegram-token")
    suspend fun verifyTelegramToken(@Body request: OneTimeTokenRequest): Response<AuthResponse>

    // You would add one for Apple here too
    // @POST("auth/apple-signin")
    // suspend fun appleSignIn(@Body request: AppleSignInRequest): Response<AuthResponse>


    @GET("auth/profile")
    suspend fun getProfile(): Response<UserProfileResponse>

    @DELETE("auth/profile")
    suspend fun deleteProfile(): Response<GenericSuccessResponse>

    // --- Structured Exam Endpoints ---
    @POST("exam/ielts/start")
    suspend fun startExam(): Response<ExamStepResponse>

    @POST("exam/ielts/step")
    suspend fun getNextExamStep(@Body request: ExamStepRequest): Response<ExamStepResponse>

    @POST("exam/ielts/analyze")
    suspend fun analyzeExam(@Body request: AnalyzeExamRequest): Response<AnalyzeExamResponse>

    @GET("exam/ielts/history")
    suspend fun getExamHistory(): Response<ExamHistorySummaryResponse>

    @GET("exam/ielts/result/{resultId}")
    suspend fun getExamResult(@Path("resultId") resultId: String): Response<ExamResultResponse>

    // --- NEW: Multilevel Exam Endpoints ---
    @GET("exam/multilevel/new")
    suspend fun getNewMultilevelExam(): Response<MultilevelExamResponse>

    @POST("exam/multilevel/analyze")
    suspend fun analyzeMultilevelExam(@Body request: MultilevelAnalyzeRequest): Response<AnalyzeExamResponse> // Response can be reused

    @GET("exam/multilevel/history")
    suspend fun getMultilevelExamHistory(): Response<MultilevelExamHistorySummaryResponse>

    @GET("exam/multilevel/result/{resultId}")
    suspend fun getMultilevelExamResult(@Path("resultId") resultId: String): Response<MultilevelExamResultResponse>


    //    NEW: WORDBANK Endpoints
    @GET("wordbank/levels")
    suspend fun getWordLevels(): Response<List<String>>

    @GET("wordbank/topics")
    suspend fun getWordTopics(@Query("level") level: String): Response<List<String>>

    @GET("wordbank/words")
    suspend fun getWords(
        @Query("level") level: String,
        @Query("topic") topic: String
    ): Response<List<ApiWord>>
}
// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/remote/RetrofitClient.kt

package com.typosbro.multilevel.data.remote

import android.content.Context
import com.google.gson.GsonBuilder
import com.typosbro.multilevel.data.local.SessionManager
import com.typosbro.multilevel.data.local.TokenManager
import com.typosbro.multilevel.data.remote.interceptors.AuthInterceptor
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.util.concurrent.TimeUnit

object RetrofitClient {

    // Replace with your actual backend URL
    const val BASE_URL =
        "http://192.168.25.6:3000/api/" // for Physical device accessing by home network IP
//    const val BASE_URL = "http://10.0.2.2:3000/api/" // for Android Emulator accessing localhost
    // const val BASE_URL = "http://192.168.1.89:3000/api/" // for Physical device accessing by work network IP


    fun getOkHttpClient(context: Context): OkHttpClient {
        val tokenManager = SessionManager(TokenManager(context.applicationContext))

        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = HttpLoggingInterceptor.Level.BASIC // Or BODY for more detail
        }
        return OkHttpClient.Builder()
            .addInterceptor(AuthInterceptor(tokenManager))
            .addInterceptor(loggingInterceptor)
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(0, TimeUnit.SECONDS) // Essential for SSE - no read timeout
            .writeTimeout(30, TimeUnit.SECONDS)
            .pingInterval(20, TimeUnit.SECONDS) // Helps keep SSE connection alive
            .build()
    }

    fun create(context: Context): ApiService {
        val tokenManager = SessionManager(TokenManager(context.applicationContext))

        // Logging Interceptor (for debugging)
        val loggingInterceptor = HttpLoggingInterceptor().apply {
            level = HttpLoggingInterceptor.Level.BODY // Log request/response bodies
        }

        // OkHttpClient with Auth Interceptor
        val okHttpClient = OkHttpClient.Builder()
            .addInterceptor(AuthInterceptor(tokenManager))
            .addInterceptor(loggingInterceptor) // Add logging last to see final request
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()

        // Gson configuration (optional, if needed)
        val gson = GsonBuilder()
            .setLenient() // If backend JSON is slightly non-standard
            .create()

        // Retrofit Instance
        val retrofit = Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create(gson))
            .build()

        return retrofit.create(ApiService::class.java)
    }
}

// Replace BASE_URL with your actual backend server address.
// If running the backend locally and testing on an Android emulator,
// http://10.0.2.2:PORT/api/ usually works.
// If testing on a physical device on the same network,
// use your computer's local network IP address
// (e.g., http://192.168.1.100:PORT/api/).
// Ensure your backend allows connections from this IP.

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/repositories/AuthRepository.kt
package com.typosbro.multilevel.data.repositories

import com.typosbro.multilevel.data.remote.ApiService
import com.typosbro.multilevel.data.remote.models.AuthResponse
import com.typosbro.multilevel.data.remote.models.GenericSuccessResponse
import com.typosbro.multilevel.data.remote.models.GoogleSignInRequest
import com.typosbro.multilevel.data.remote.models.OneTimeTokenRequest
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import com.typosbro.multilevel.data.remote.models.UserProfileResponse
import com.typosbro.multilevel.data.remote.models.safeApiCall
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

// --- Auth Repository ---
class AuthRepository(private val apiService: ApiService) {


    suspend fun googleSignIn(request: GoogleSignInRequest): RepositoryResult<AuthResponse> =
        withContext(Dispatchers.IO) {
            safeApiCall { apiService.googleSignIn(request) }
        }

    suspend fun verifyTelegramToken(request: OneTimeTokenRequest): RepositoryResult<AuthResponse> =
        withContext(Dispatchers.IO) {
            safeApiCall { apiService.verifyTelegramToken(request) }
        }

    suspend fun getUserProfile(): RepositoryResult<UserProfileResponse> =
        withContext(Dispatchers.IO) {
            safeApiCall { apiService.getProfile() }
        }

    suspend fun deleteUserProfile(): RepositoryResult<GenericSuccessResponse> =
        withContext(Dispatchers.IO) {
            safeApiCall { apiService.deleteProfile() }
        }
}
// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/repositories/ChatRepository.kt
package com.typosbro.multilevel.data.repositories

import com.typosbro.multilevel.data.remote.ApiService
import com.typosbro.multilevel.data.remote.models.AnalyzeExamRequest
import com.typosbro.multilevel.data.remote.models.AnalyzeExamResponse
import com.typosbro.multilevel.data.remote.models.ExamHistorySummaryResponse
import com.typosbro.multilevel.data.remote.models.ExamResultResponse
import com.typosbro.multilevel.data.remote.models.ExamStepRequest
import com.typosbro.multilevel.data.remote.models.ExamStepResponse
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import com.typosbro.multilevel.data.remote.models.TranscriptEntry
import com.typosbro.multilevel.data.remote.models.safeApiCall
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ChatRepository @Inject constructor(
    private val apiService: ApiService
) {

    suspend fun getInitialExamQuestion(): RepositoryResult<ExamStepResponse> =
        safeApiCall { apiService.startExam() }

    suspend fun getNextExamStep(request: ExamStepRequest): RepositoryResult<ExamStepResponse> {
        return safeApiCall { apiService.getNextExamStep(request) }
    }

    suspend fun analyzeFullExam(transcript: List<TranscriptEntry>): RepositoryResult<AnalyzeExamResponse> {
        val request = AnalyzeExamRequest(transcript)
        return safeApiCall { apiService.analyzeExam(request) }
    }

    suspend fun getExamHistorySummary(): RepositoryResult<ExamHistorySummaryResponse> =
        safeApiCall { apiService.getExamHistory() }

    suspend fun getExamResultDetails(resultId: String): RepositoryResult<ExamResultResponse> =
        safeApiCall { apiService.getExamResult(resultId) }
}
// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/repositories/MultilevelExamRepository.kt
package com.typosbro.multilevel.data.repositories

import com.typosbro.multilevel.data.remote.ApiService
import com.typosbro.multilevel.data.remote.models.AnalyzeExamResponse
import com.typosbro.multilevel.data.remote.models.MultilevelAnalyzeRequest
import com.typosbro.multilevel.data.remote.models.MultilevelExamHistorySummaryResponse
import com.typosbro.multilevel.data.remote.models.MultilevelExamResponse
import com.typosbro.multilevel.data.remote.models.MultilevelExamResultResponse
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import com.typosbro.multilevel.data.remote.models.safeApiCall
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class MultilevelExamRepository @Inject constructor(
    private val apiService: ApiService
) {
    suspend fun getNewExam(): RepositoryResult<MultilevelExamResponse> =
        safeApiCall { apiService.getNewMultilevelExam() }

    suspend fun analyzeExam(request: MultilevelAnalyzeRequest): RepositoryResult<AnalyzeExamResponse> =
        safeApiCall { apiService.analyzeMultilevelExam(request) }


    // You would also add history and result details functions here
    suspend fun getExamHistory(): RepositoryResult<MultilevelExamHistorySummaryResponse> =
        safeApiCall { apiService.getMultilevelExamHistory() }

    suspend fun getExamResultDetails(examId: String): RepositoryResult<MultilevelExamResultResponse> =
        safeApiCall { apiService.getMultilevelExamResult(examId) }
}
// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/repositories/SseListenerRepository.kt

package com.typosbro.multilevel.data.repositories

import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import com.typosbro.multilevel.data.remote.models.* // Import all the new stream event models
import kotlinx.coroutines.channels.ProducerScope
import okhttp3.Response
import okhttp3.sse.EventSource
import okhttp3.sse.EventSourceListener

/**
 * A generic SSE Listener for the FREESTYLE CHAT stream.
 * It parses events and emits them into a Flow's ProducerScope.
 */
class SseListenerRepository(
    private val scope: ProducerScope<ChatStreamEvent>,
    private val gson: Gson
) : EventSourceListener() {

    override fun onEvent(eventSource: EventSource, id: String?, type: String?, data: String) {
        if (scope.isClosedForSend) return

        try {
            // Parse the data, which might result in a nullable object
            val parsedEvent: ChatStreamEvent? = when (type) {
                "text_chunk" -> gson.fromJson(data, TextChunk::class.java)?.let { ChatStreamEvent.TextChunk(it.text) }
                "input_ids_chunk" -> gson.fromJson(data, InputIdsChunk::class.java)?.let { ChatStreamEvent.InputIdsChunk(it.sentence, it.input_ids) }
                "stream_end" -> gson.fromJson(data, StreamEnd::class.java)?.let { ChatStreamEvent.StreamEnd(it.message) }
                "preprocess_warning" -> gson.fromJson(data, PreprocessWarning::class.java)?.let { ChatStreamEvent.PreprocessWarning(it.message, it.sentenceText) }
                "preprocess_error" -> gson.fromJson(data, PreprocessError::class.java)?.let { ChatStreamEvent.PreprocessError(it.message, it.sentenceText) }
                "error" -> gson.fromJson(data, StreamError::class.java)?.let { ChatStreamEvent.StreamError(it.message, it.details) }
                else -> null
            }

            // --- FIX: Only try to send if the parsed event is not null. ---
            if (parsedEvent != null) {
                scope.trySend(parsedEvent)
            }
        } catch (e: JsonSyntaxException) {
            scope.trySend(ChatStreamEvent.StreamError("Failed to parse event data: ${e.message}", data))
        }
    }

    override fun onOpen(eventSource: EventSource, response: Response) {}

    override fun onClosed(eventSource: EventSource) {
        scope.close()
    }

    override fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) {
        val errorMessage = t?.message ?: response?.message ?: "Unknown SSE error"
        scope.trySend(ChatStreamEvent.StreamError(errorMessage, response?.body?.string()))
        scope.close(t)
    }
}

/**
 * A specific SSE Listener for the EXAM stream.
 */
class ExamSseListener(
    private val scope: ProducerScope<ExamEvent>,
    private val gson: Gson
) : EventSourceListener() {

    override fun onEvent(eventSource: EventSource, id: String?, type: String?, data: String) {
        if (scope.isClosedForSend) return

        try {
            val parsedEvent: ExamEvent? = when (type) {
                "text_chunk" -> gson.fromJson(data, TextChunk::class.java)?.let { ExamEvent.TextChunk(it.text) }
                "input_ids_chunk" -> gson.fromJson(data, InputIdsChunk::class.java)?.let { ExamEvent.InputIdsChunk(it.sentence, it.input_ids) }
                "stream_end" -> gson.fromJson(data, ExamStreamEndData::class.java)?.let { ExamEvent.StreamEnd(it) }
                "error" -> gson.fromJson(data, StreamError::class.java)?.let { ExamEvent.StreamError(it.message) }
                else -> null
            }

            // --- FIX: Only try to send if the parsed event is not null. ---
            if (parsedEvent != null) {
                scope.trySend(parsedEvent)
            }
        } catch (e: JsonSyntaxException) {
            scope.trySend(ExamEvent.StreamError("Failed to parse event data: ${e.message}"))
        }
    }

    override fun onOpen(eventSource: EventSource, response: Response) {}

    override fun onClosed(eventSource: EventSource) {
        scope.close()
    }

    override fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) {
        val errorMessage = t?.message ?: response?.message ?: "Unknown SSE error during exam"
        scope.trySend(ExamEvent.StreamError(errorMessage))
        scope.close(t)
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/repositories/WordBankRepository.kt
package com.typosbro.multilevel.data.repositories

import com.typosbro.multilevel.data.remote.ApiService
import com.typosbro.multilevel.data.remote.models.ApiWord
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import com.typosbro.multilevel.data.remote.models.safeApiCall
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class WordBankRepository @Inject constructor(
    private val apiService: ApiService
) {

    suspend fun getLevels(): RepositoryResult<List<String>> =
        safeApiCall { apiService.getWordLevels() }

    suspend fun getTopics(level: String): RepositoryResult<List<String>> =
        safeApiCall { apiService.getWordTopics(level) }

    suspend fun getWords(level: String, topic: String): RepositoryResult<List<ApiWord>> =
        safeApiCall { apiService.getWords(level, topic) }

    /**
     * --- NEW: Fetches all words for an entire level ---
     * This is done by first getting all topics for the level, then fetching words for each topic concurrently.
     */
    suspend fun getAllWordsForLevel(level: String): RepositoryResult<List<ApiWord>> {
        // First, get all topics for the given level.
        val topicsResult = getTopics(level)
        if (topicsResult is RepositoryResult.Error) {
            return topicsResult // Propagate the error if we can't get topics.
        }
        val topics = (topicsResult as RepositoryResult.Success).data

        // Concurrently fetch words for each topic.
        return try {
            coroutineScope {
                val deferredWords = topics.map { topic ->
                    async { getWords(level, topic) }
                }
                val results = deferredWords.awaitAll()

                val allWords = mutableListOf<ApiWord>()
                // Check if any of the calls failed.
                results.forEach { result ->
                    when (result) {
                        is RepositoryResult.Success -> allWords.addAll(result.data)
                        is RepositoryResult.Error -> {
                            // If any single topic fails, we return the first error found.
                            return@coroutineScope RepositoryResult.Error("Failed to fetch words for one or more topics: ${result.message}")
                        }
                    }
                }
                RepositoryResult.Success(allWords)
            }
        } catch (e: Exception) {
            RepositoryResult.Error("An unexpected error occurred while fetching all words for level $level: ${e.message}")
        }
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/di/AppModule.kt
package com.typosbro.multilevel.di


import android.content.Context
import com.typosbro.multilevel.data.local.TokenManager
import com.typosbro.multilevel.data.local.WordDao
import com.typosbro.multilevel.data.local.WordDatabase
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class) // These dependencies will live as long as the app does
object AppModule {


}

package com.typosbro.multilevel.di

import android.content.Context
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.preferencesDataStore
import com.typosbro.multilevel.data.local.SessionManager
import com.typosbro.multilevel.data.local.TokenManager
import com.typosbro.multilevel.data.local.WordDao
import com.typosbro.multilevel.data.local.WordDatabase
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

// --- ADD THIS TOP-LEVEL DELEGATE ---
// Define the DataStore file name and the delegate once, in a central place.
private const val SETTINGS_PREFERENCES = "settings_prefs"
private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = SETTINGS_PREFERENCES)
// ------------------------------------


@Module
@InstallIn(SingletonComponent::class)
object DataModule {

    // --- ADD THIS NEW PROVIDER ---
    @Provides
    @Singleton
    fun providePreferencesDataStore(@ApplicationContext context: Context): DataStore<Preferences> {
        return context.dataStore
    }
    // -----------------------------

    @Provides
    @Singleton
    fun provideTokenManager(@ApplicationContext context: Context): TokenManager {
        return TokenManager(context)
    }

    @Provides
    @Singleton
    fun provideWordDatabase(@ApplicationContext context: Context): WordDatabase {
        return WordDatabase.getDatabase(context)
    }

    @Provides
    @Singleton
    fun provideWordDao(database: WordDatabase): WordDao {
        return database.wordDao()
    }

    @Provides
    @Singleton
    fun provideSessionManager(tokenManager: TokenManager): SessionManager {
        return SessionManager(tokenManager)
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/data/di/HiltApplication.kt
package com.typosbro.multilevel.di

import android.app.Application
import com.typosbro.multilevel.features.inference.OnnxRuntimeManager
import dagger.hilt.android.HiltAndroidApp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

@HiltAndroidApp
class MultilevelApplication : Application() {
    // Use a coroutine scope that lives as long as the application itself
    private val applicationScope = CoroutineScope(Dispatchers.Default)

    override fun onCreate() {
        super.onCreate()

        // Launch the initialization on a background thread so it doesn't block
        // the main thread during app startup.
        applicationScope.launch {
            OnnxRuntimeManager.initialize(this@MultilevelApplication)
        }
    }

}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/di/NetworkModule.kt
package com.typosbro.multilevel.di

import com.typosbro.multilevel.data.local.SessionManager
import com.typosbro.multilevel.data.remote.ApiService
import com.typosbro.multilevel.data.remote.RetrofitClient
import com.typosbro.multilevel.data.remote.interceptors.AuthInterceptor
import com.typosbro.multilevel.data.repositories.AuthRepository
import com.typosbro.multilevel.data.repositories.ChatRepository
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import okhttp3.OkHttpClient
import okhttp3.logging.HttpLoggingInterceptor
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import java.util.concurrent.TimeUnit
import javax.inject.Named
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    @Provides
    @Singleton
    fun provideAuthInterceptor(sessionManager: SessionManager): AuthInterceptor {
        return AuthInterceptor(sessionManager)
    }

    @Provides
    @Singleton
    @Named("StandardOkHttpClient")
    fun provideStandardOkHttpClient(authInterceptor: AuthInterceptor): OkHttpClient { // <-- Change parameter
        return OkHttpClient.Builder()
            .addInterceptor(authInterceptor) // <-- Use the injected interceptor
            .addInterceptor(HttpLoggingInterceptor().apply {
                level = HttpLoggingInterceptor.Level.BODY
            })
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }

    @Provides
    @Singleton
    @Named("SseOkHttpClient")
    fun provideSseOkHttpClient(authInterceptor: AuthInterceptor): OkHttpClient { // <-- Change parameter
        return OkHttpClient.Builder()
            .addInterceptor(authInterceptor) // <-- Use the injected interceptor
            .addInterceptor(HttpLoggingInterceptor().apply {
                level = HttpLoggingInterceptor.Level.BODY
            })
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(0, TimeUnit.SECONDS) // No read timeout for SSE
            .writeTimeout(30, TimeUnit.SECONDS)
            .pingInterval(20, TimeUnit.SECONDS)
            .build()
    }


    @Provides
    @Singleton
    fun provideApiService(@Named("StandardOkHttpClient") okHttpClient: OkHttpClient): ApiService {
        return Retrofit.Builder()
            .baseUrl(RetrofitClient.BASE_URL)
            .client(okHttpClient) // Use the standard client for regular API calls
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(ApiService::class.java)
    }

    @Provides
    @Singleton
    fun provideAuthRepository(apiService: ApiService): AuthRepository {
        return AuthRepository(apiService)
    }

    @Provides
    @Singleton
    fun provideChatRepository(
        apiService: ApiService,
    ): ChatRepository = ChatRepository(apiService)
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/features/inference/OnnxRuntimeManager.kt
// Adopted from: https://github.com/puff-dayo/Kokoro-82M-Android


package com.typosbro.multilevel.features.inference

import ai.onnxruntime.OrtEnvironment
import ai.onnxruntime.OrtSession
import ai.onnxruntime.OrtSession.SessionOptions
import android.content.Context
import android.util.Log
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.io.InputStream
import java.io.OutputStream

object OnnxRuntimeManager {
    private var environment: OrtEnvironment? = null
    private var session: OrtSession? = null
    private const val MODEL_FILE_NAME = "model_quantized.onnx"


    @Synchronized
    fun initialize(context: Context) {
        if (environment == null) {
            try {
                environment = OrtEnvironment.getEnvironment()
                session = createSession(context)
            } catch (e: Exception) {
                Log.e("OnnxRuntimeManager", "Error initializing ONNX Runtime: ${e.message}", e)
                // Optionally, rethrow or handle this error more gracefully in your UI
                throw e // Rethrow to make it visible during development
            }
        }
    }

    private fun copyModelToCache(context: Context): File {
        val modelFile = File(context.cacheDir, MODEL_FILE_NAME)
        var inputStream: InputStream? = null
        var outputStream: OutputStream? = null

        try {
            if (modelFile.exists()) {
                Log.d(
                    "OnnxRuntimeManager",
                    "Model already exists in cache: ${modelFile.absolutePath}"
                )
                // Optional: Add a version check here if your model in res/raw can change
                // For now, we assume if it exists, it's the correct one.
                return modelFile
            }

            Log.d("OnnxRuntimeManager", "Copying model to cache: ${modelFile.absolutePath}")
            inputStream =
                context.assets.open(MODEL_FILE_NAME)
            outputStream = FileOutputStream(modelFile)
            val buffer = ByteArray(4 * 1024) // 4K buffer
            var read: Int
            while (inputStream.read(buffer).also { read = it } != -1) {
                outputStream.write(buffer, 0, read)
            }
            Log.d("OnnxRuntimeManager", "Model copied successfully.")
        } catch (e: IOException) {
            Log.e("OnnxRuntimeManager", "Failed to copy model to cache", e)
            // Clean up partially written file if copy failed
            if (modelFile.exists()) {
                modelFile.delete()
            }
            throw e // Rethrow to indicate failure
        } finally {
            try {
                inputStream?.close()
                outputStream?.close()
            } catch (e: IOException) {
                Log.e("OnnxRuntimeManager", "Error closing streams", e)
            }
        }
        return modelFile
    }

    private fun createSession(context: Context): OrtSession {
        val options = SessionOptions().apply {
            // Your existing options
            addConfigEntry("nnapi.flags", "USE_FP16")
            addConfigEntry(
                "nnapi.use_gpu",
                "true"
            ) // Ensure NNAPI is available and model supports it
            addConfigEntry("nnapi.gpu_precision_loss_allowed", "true")
            // Consider adding optimization levels if needed, e.g.:
            // setOptimizationLevel(OrtSession.SessionOptions.OptLevel.ORT_ENABLE_ALL)
        }

        // Copy the model to internal storage and get its path
        val modelFile = copyModelToCache(context.applicationContext) // Use applicationContext

        Log.d("OnnxRuntimeManager", "Creating session from model path: ${modelFile.absolutePath}")
        // Create the session using the file path
        return environment!!.createSession(modelFile.absolutePath, options)
    }

    fun getSession() = requireNotNull(session) { "ONNX Session not initialized" }

    // Optional: Add a method to close the session if MainViewModel is ever designed to do so
    @Synchronized
    fun close() {
        try {
            session?.close()
            environment?.close() // Close environment when completely done
        } catch (e: Exception) {
            Log.e("OnnxRuntimeManager", "Error closing ONNX session/environment", e)
        } finally {
            session = null
            environment = null
        }
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/features/inference/StyleLoader.kt

// Adopted from: https://github.com/puff-dayo/Kokoro-82M-Android

package com.typosbro.multilevel.features.inference // Ensure this matches your package structure

import android.content.Context
import java.io.InputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder

val names = listOf(
    "bf_alice",
    "bf_emma",
    "bf_isabella",
    "bm_george",
    "bm_lewis"
)

class StyleLoader(private val context: Context) {



    private val styleResourceMap: Map<String, Int> = names.associateWith { name ->
        val resourceId = context.resources.getIdentifier(name, "raw", context.packageName)
        if (resourceId == 0) {
            throw IllegalArgumentException("Resource binary file '$name' not found in /res/raw. Ensure binary voice files are present with these exact names and no extensions.")
        }
        resourceId
    }

    fun getStyleArray(name: String, index: Int = 0): Array<FloatArray> {
        val resourceId = styleResourceMap[name]
            ?: throw IllegalArgumentException("Style '$name' not found. Ensure it's in the 'names' list and the corresponding binary file exists in /res/raw.")

        val inputStream: InputStream = context.resources.openRawResource(resourceId)
        val bytes: ByteArray = inputStream.use { it.readBytes() }

        // --- Configuration for your style vectors (elements per vector) ---
        val floatsPerVector = 256
        val bytesPerFloat = 4
        // --- End Configuration ---

        // Dynamically calculate the number of vectors based on file size
        if (bytes.size % (floatsPerVector * bytesPerFloat) != 0) {
            throw IllegalArgumentException(
                "Binary voice file '$name' has a size (${bytes.size} bytes) that is not a " +
                        "multiple of the expected vector size in bytes (${floatsPerVector * bytesPerFloat} bytes)."
            )
        }
        val numVectorsInFile = bytes.size / (floatsPerVector * bytesPerFloat)

        if (numVectorsInFile == 0) {
            throw IllegalArgumentException(
                "Binary voice file '$name' appears to be empty or too small to contain any vectors."
            )
        }

        // The 'index' parameter selects which of the 'numVectorsInFile' to load.
        if (index < 0 || index >= numVectorsInFile) {
            throw IllegalArgumentException(
                "Index ($index) is out of bounds for file '$name' which contains $numVectorsInFile vectors (valid range: 0 to ${numVectorsInFile - 1})."
            )
        }

        val byteBuffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN)
        val floatBuffer = byteBuffer.asFloatBuffer()

        val styleArray = Array(1) { FloatArray(floatsPerVector) }

        val floatOffsetForSelectedVector = index * floatsPerVector

        floatBuffer.position(floatOffsetForSelectedVector)
        floatBuffer.get(styleArray[0], 0, floatsPerVector)

        return styleArray
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/features/srs/SM2.kt
package com.typosbro.multilevel.features.srs

import com.typosbro.multilevel.data.local.WordEntity
import java.util.concurrent.TimeUnit
import kotlin.math.ceil

/**
 * Represents the quality of a user's response during a review session.
 * These map to the q-values used in the SM-2 algorithm.
 */
enum class ReviewQuality {
    AGAIN, // q < 3 (Incorrect response, needs to be repeated soon)
    HARD,  // q = 3 (Correct, but with serious difficulty)
    GOOD,  // q = 4 (Correct, but with some hesitation)
    EASY   // q = 5 (Perfect response)
}

/**
 * An object that implements the SM-2 algorithm for spaced repetition scheduling.
 * Based on the paper by P.A. Wozniak.
 */
object SM2 {

    private const val MIN_EASINESS_FACTOR = 1.3f

    /**
     * Calculates the next review state for a word based on the user's recall quality.
     *
     * @param word The word entity being reviewed.
     * @param quality The user's assessment of the recall quality.
     * @return The updated WordEntity with new SRS parameters.
     */
    fun calculate(word: WordEntity, quality: ReviewQuality): WordEntity {
        // Map the UI quality to the numeric q-value used in the SM-2 formula.
        val q = when (quality) {
            ReviewQuality.AGAIN -> 2 // Any value < 3 will reset the card.
            ReviewQuality.HARD -> 3
            ReviewQuality.GOOD -> 4
            ReviewQuality.EASY -> 5
        }

        // If the quality is below 3, the user failed to recall the item.
        // Reset the repetition sequence for this word.
        if (q < 3) {
            return word.copy(
                repetitions = 0, // Reset the count of successful repetitions.
                interval = 0,    // Reset the interval.
                // Schedule the word for review again in 1 day.
                nextReviewTimestamp = System.currentTimeMillis() + TimeUnit.DAYS.toMillis(1)
            )
        }

        // If the quality is 3 or higher, the user recalled the item correctly.
        // 1. Calculate the new easiness factor (EF).
        val oldEF = word.easinessFactor
        val newEF = (oldEF + (0.1 - (5 - q) * (0.08 + (5 - q) * 0.02))).toFloat()
        val correctedEF = newEF.coerceAtLeast(MIN_EASINESS_FACTOR)

        // 2. Calculate the new interval based on the number of successful repetitions.
        val newRepetitions = word.repetitions + 1
        val newInterval = when (newRepetitions) {
            1 -> 1
            2 -> 6
            else -> {
                // I(n) = I(n-1) * EF
                // Here, `word.interval` is the previous interval, I(n-1).
                ceil(word.interval * correctedEF).toInt()
            }
        }

        // 3. Calculate the next review date in milliseconds.
        val nextReviewTime =
            System.currentTimeMillis() + TimeUnit.DAYS.toMillis(newInterval.toLong())

        // 4. Return the updated word with new SRS values.
        return word.copy(
            repetitions = newRepetitions,
            easinessFactor = correctedEF,
            interval = newInterval,
            nextReviewTimestamp = nextReviewTime
        )
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/features/whisper/engine/WhisperEngine.java
package com.typosbro.multilevel.features.whisper.engine;

import java.io.IOException;

public interface WhisperEngine {
    boolean isInitialized();
    boolean initialize(String modelPath, String vocabPath, boolean multilingual) throws IOException;
    void deinitialize();
    String transcribeFile(String wavePath);
    String transcribeBuffer(float[] samples);
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/features/whisper/engine/WhisperEngineNative.java

package com.typosbro.multilevel.features.whisper.engine;

import android.content.Context;
import android.util.Log;

public class WhisperEngineNative implements WhisperEngine {
    static {
        // This must match the 'target_name' in the native code's CMakeLists.txt
        System.loadLibrary("audioEngine");
    }

    private final String TAG = "WhisperEngineNative";
    private long nativePtr; // Make it non-final to allow proper release
    private boolean mIsInitialized = false;

    public WhisperEngineNative(Context context) {
        // The native pointer is initialized here.
        // It's crucial to release it later to avoid memory leaks.
        nativePtr = createTFLiteEngine();
    }

    @Override
    public boolean isInitialized() {
        return mIsInitialized;
    }

    @Override
    public boolean initialize(String modelPath, String vocabPath, boolean multilingual) {
        if (nativePtr == 0) {
            Log.e(TAG, "Cannot initialize, native pointer is null.");
            return false;
        }
        int ret = loadModel(modelPath, multilingual);
        Log.d(TAG, "Native model loaded: " + modelPath + ", result: " + ret);
        mIsInitialized = (ret == 0);
        return mIsInitialized;
    }

    @Override
    public void deinitialize() {
        if (nativePtr != 0) {
            freeModel();
            // After freeing the native resources, destroy the engine itself
            nativePtr = 0; // Set to 0 to prevent reuse
        }
        mIsInitialized = false;
    }

    @Override
    public String transcribeBuffer(float[] samples) {
        if (!mIsInitialized || nativePtr == 0) {
            Log.w(TAG, "transcribeBuffer called before engine was initialized or after it was released.");
            return "";
        }

        // --- THE FIX IS HERE ---
        // Wrap the native call in a try-catch block for any Throwable.
        try {
            // This is the call that is causing the native crash.
            String result = transcribeBuffer(nativePtr, samples);

            // It's also good practice to check for a null result from JNI.
            if (result == null) {
                Log.w(TAG, "Native transcribeBuffer returned null. Returning empty string.");
                return "";
            }
            return result;

        } catch (Throwable t) {
            // Catch any error, including the JNI UTF-8 error, which is a Throwable.
            Log.e(TAG, "FATAL: Native 'transcribeBuffer' call failed and was caught.", t);

            // Return a safe, empty string to prevent the app from crashing.
            return "";
        }
    }

    @Override
    public String transcribeFile(String waveFile) {
        if (!mIsInitialized || nativePtr == 0) {
            Log.w(TAG, "transcribeFile called before engine was initialized or after it was released.");
            return "";
        }

        // --- ALSO APPLY THE FIX HERE FOR CONSISTENCY ---
        try {
            String result = transcribeFile(nativePtr, waveFile);
            if (result == null) {
                Log.w(TAG, "Native transcribeFile returned null. Returning empty string.");
                return "";
            }
            return result;
        } catch (Throwable t) {
            Log.e(TAG, "FATAL: Native 'transcribeFile' call failed and was caught.", t);
            return "";
        }
    }

    private int loadModel(String modelPath, boolean isMultilingual) {
        return loadModel(nativePtr, modelPath, isMultilingual);
    }

    private void freeModel() {
        freeModel(nativePtr);
    }

    // --- Native methods ---
    private native long createTFLiteEngine();


    private native int loadModel(long nativePtr, String modelPath, boolean isMultilingual);

    private native void freeModel(long nativePtr);

    private native String transcribeBuffer(long nativePtr, float[] samples);

    private native String transcribeFile(long nativePtr, String waveFile);
}
// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/features/whisper/Recorder.java

package com.typosbro.multilevel.features.whisper;

import android.Manifest;
import android.content.Context;
import android.content.pm.PackageManager;
import android.media.AudioFormat;
import android.media.AudioRecord;
import android.media.MediaRecorder;
import android.util.Log;

import androidx.core.app.ActivityCompat;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.concurrent.atomic.AtomicBoolean;

public class Recorder {

    private static final String TAG = "Recorder";
    private final Context mContext;
    private final AtomicBoolean mIsRecording = new AtomicBoolean(false);
    private final RecorderListener mListener;
    private Thread recordingThread;

    public Recorder(Context context, RecorderListener listener) {
        this.mContext = context;
        this.mListener = listener;
    }

    public boolean isRecording() {
        return mIsRecording.get();
    }

    public void start() {
        if (mIsRecording.get()) {
            Log.d(TAG, "Recording is already in progress...");
            return;
        }
        mIsRecording.set(true);
        recordingThread = new Thread(this::recordAudio);
        recordingThread.start();
    }

    public void stop() {
        if (!mIsRecording.get()) return;
        mIsRecording.set(false);
    }

    private void recordAudio() {
        if (ActivityCompat.checkSelfPermission(mContext, Manifest.permission.RECORD_AUDIO) != PackageManager.PERMISSION_GRANTED) {
            Log.e(TAG, "Permission not granted for recording");
            mIsRecording.set(false);
            if (mListener != null) mListener.onRecordingStopped(); // Notify listener on error
            return;
        }

        Log.d(TAG, "Starting audio recording thread.");
        AudioRecord audioRecord = null;
        try {
            int sampleRateInHz = 16000;
            int channelConfig = AudioFormat.CHANNEL_IN_MONO;
            int audioFormat = AudioFormat.ENCODING_PCM_16BIT;
            int bufferSizeInBytes = AudioRecord.getMinBufferSize(sampleRateInHz, channelConfig, audioFormat);
            audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, sampleRateInHz, channelConfig, audioFormat, bufferSizeInBytes);

            audioRecord.startRecording();
            byte[] audioData = new byte[bufferSizeInBytes];

            while (mIsRecording.get()) {
                int bytesRead = audioRecord.read(audioData, 0, audioData.length);
                if (bytesRead > 0 && mListener != null) {
                    float[] samples = convertToFloatArray(ByteBuffer.wrap(audioData, 0, bytesRead));
                    mListener.onDataReceived(samples);
                } else if (bytesRead < 0) {
                    Log.e(TAG, "AudioRecord read error: " + bytesRead);
                    break;
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "Exception during recording", e);
        } finally {
            Log.d(TAG, "Stopping audio recording thread.");
            mIsRecording.set(false);
            if (audioRecord != null) {
                if (audioRecord.getRecordingState() == AudioRecord.RECORDSTATE_RECORDING) {
                    audioRecord.stop();
                }
                audioRecord.release();
            }
            // --- THIS IS THE KEY ---
            // Ensure the listener is always called when the thread finishes.
            if (mListener != null) {
                mListener.onRecordingStopped();
            }
        }
    }

    private float[] convertToFloatArray(ByteBuffer buffer) {
        buffer.order(ByteOrder.LITTLE_ENDIAN);
        float[] samples = new float[buffer.remaining() / 2];
        for (int i = 0; i < samples.length; i++) {
            samples[i] = buffer.getShort() / 32768.0f;
        }
        return samples;
    }

    public interface RecorderListener {
        void onDataReceived(float[] samples);

        void onRecordingStopped();
    }
}
package com.typosbro.multilevel.features.whisper

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Intent
import android.os.Binder
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import com.typosbro.multilevel.MainActivity

class RecordingService : Service() {

    companion object {
        private const val TAG = "RecordingService"
        private const val NOTIFICATION_ID = 1001
        private const val CHANNEL_ID = "exam_recording_channel"
        private const val CHANNEL_NAME = "Exam Recording"

        const val ACTION_START_RECORDING = "start_recording"
        const val ACTION_STOP_RECORDING = "stop_recording"
    }

    private val binder = LocalBinder()
    private var recorder: Recorder? = null
    private var recorderListener: Recorder.RecorderListener? = null

    inner class LocalBinder : Binder() {
        fun getService(): RecordingService = this@RecordingService
    }

    override fun onBind(intent: Intent): IBinder {
        return binder
    }

    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
        Log.d(TAG, "RecordingService created")
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            ACTION_START_RECORDING -> {
                startForegroundRecording()
            }

            ACTION_STOP_RECORDING -> {
                stopRecording()
                stopSelf()
            }
        }

        // Return START_NOT_STICKY so service doesn't restart if killed
        return START_NOT_STICKY
    }

    fun setRecorderListener(listener: Recorder.RecorderListener) {
        this.recorderListener = listener
    }

    fun startRecording(): Boolean {
        if (recorder?.isRecording == true) {
            Log.d(TAG, "Recording already in progress")
            return true
        }

        return try {
            recorder = Recorder(this, recorderListener ?: object : Recorder.RecorderListener {
                override fun onDataReceived(samples: FloatArray) {
                    // Default empty implementation
                }

                override fun onRecordingStopped() {
                    // Default empty implementation
                }
            })

            recorder?.start()
            startForeground(NOTIFICATION_ID, createNotification())
            Log.d(TAG, "Recording started in foreground service")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Failed to start recording", e)
            false
        }
    }

    fun stopRecording() {
        recorder?.stop()
        recorder = null
        stopForeground(true)
        Log.d(TAG, "Recording stopped")
    }

    fun isRecording(): Boolean {
        return recorder?.isRecording == true
    }

    private fun startForegroundRecording() {
        startRecording()
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                CHANNEL_NAME,
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "Notification for exam recording session"
                setSound(null, null)
                enableVibration(false)
            }

            val notificationManager =
                getSystemService(NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }

    private fun createNotification(): Notification {
        val intent = Intent(this, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }

        val pendingIntent = PendingIntent.getActivity(
            this, 0, intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val stopIntent = Intent(this, RecordingService::class.java).apply {
            action = ACTION_STOP_RECORDING
        }

        PendingIntent.getService(
            this, 1, stopIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("IELTS Speaking Test")
            .setContentText("Recording in progress...")
//            .setSmallIcon(R.drawable.ic_mic) // Make sure you have this icon
            .setContentIntent(pendingIntent)
//            .addAction(R.drawable.ic_stop, "Stop", stopPendingIntent)
            .setOngoing(true)
            .setSilent(true)
            .setCategory(NotificationCompat.CATEGORY_SERVICE)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .build()
    }

    override fun onDestroy() {
        super.onDestroy()
        stopRecording()
        Log.d(TAG, "RecordingService destroyed")
    }
}


// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/navigation/AppNavigation.kt
package com.typosbro.multilevel.navigation

import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument
import com.typosbro.multilevel.data.local.SessionManager
import com.typosbro.multilevel.ui.screens.MainScreen
import com.typosbro.multilevel.ui.screens.auth.LoginScreen
import com.typosbro.multilevel.ui.screens.practice.ExamResultScreen
import com.typosbro.multilevel.ui.screens.practice.ExamScreen
import com.typosbro.multilevel.ui.screens.practice.MultilevelExamScreen
import com.typosbro.multilevel.ui.screens.practice.MultilevelResultScreen
import com.typosbro.multilevel.ui.viewmodels.AuthViewModel

// Define navigation routes
object AppDestinations {
    const val LOGIN_ROUTE = "login"
    const val REGISTER_ROUTE = "register"
    const val MAIN_HUB_ROUTE = "main_hub"
    const val EXAM_SCREEN_ROUTE = "exam_screen"
    const val EXAM_RESULT_ROUTE = "exam_result/{resultId}"
    const val MULTILEVEL_EXAM_ROUTE = "multilevel_exam/{practicePart}"
    const val MULTILEVEL_RESULT_ROUTE = "multilevel_result/{resultId}"
}

@Composable
fun AppNavigation(
    navController: NavHostController = rememberNavController()
) {
    val authViewModel: AuthViewModel = hiltViewModel()
    val sessionManager: SessionManager = authViewModel.getSessionManager()

    val startDestination by remember {
        mutableStateOf(
            if (sessionManager.tokenFlow.value != null) AppDestinations.MAIN_HUB_ROUTE else AppDestinations.LOGIN_ROUTE
        )
    }

    // This effect is now observing the rock-solid StateFlow from SessionManager.
    val token by sessionManager.tokenFlow.collectAsState()

    LaunchedEffect(key1 = token) {
        val currentRoute = navController.currentDestination?.route
        val onAuthScreen =
            currentRoute == AppDestinations.LOGIN_ROUTE || currentRoute == AppDestinations.REGISTER_ROUTE

        if (token == null && !onAuthScreen) {
            navController.navigate(AppDestinations.LOGIN_ROUTE) {
                popUpTo(navController.graph.startDestinationId) { inclusive = true }
                launchSingleTop = true
            }
        } else if (token != null && onAuthScreen) {
            navController.navigate(AppDestinations.MAIN_HUB_ROUTE) {
                popUpTo(navController.graph.startDestinationId) { inclusive = true }
                launchSingleTop = true
            }
        }
    }

    NavHost(
        navController = navController,
        startDestination = startDestination
    ) {
        composable(AppDestinations.LOGIN_ROUTE) {
            LoginScreen()
        }


        composable(AppDestinations.MAIN_HUB_ROUTE) {
            MainScreen(
                onNavigateToIELTS = {
                    navController.navigate(AppDestinations.EXAM_SCREEN_ROUTE)
                },
                // UPDATED: This lambda now takes the part string
                onNavigateToMultilevel = { practicePart ->
                    navController.navigate("multilevel_exam/$practicePart")
                },
                onNavigateToIeltsResult = { resultId ->
                    navController.navigate("exam_result/$resultId")
                },
                onNavigateToMultilevelResult = { resultId ->
                    navController.navigate("multilevel_result/$resultId")
                }
            )
        }

        composable(AppDestinations.EXAM_SCREEN_ROUTE) {
            ExamScreen(
                onNavigateToResults = { resultId ->
                    navController.navigate("exam_result/$resultId") {
                        popUpTo(AppDestinations.EXAM_SCREEN_ROUTE) { inclusive = true }
                    }
                }
            )
        }
        composable(
            route = AppDestinations.EXAM_RESULT_ROUTE,
            arguments = listOf(navArgument("resultId") { type = NavType.StringType })
        ) {
            ExamResultScreen(onNavigateBack = { navController.popBackStack() })
        }

        composable(
            route = AppDestinations.MULTILEVEL_EXAM_ROUTE,
            arguments = listOf(navArgument("practicePart") { type = NavType.StringType })
        ) {
            MultilevelExamScreen(
                onNavigateToResults = { resultId ->
                    navController.navigate("multilevel_result/$resultId") {
                        // Pop back to the multilevel practice hub, not just the exam screen
                        popUpTo(navController.graph.id) {
                            inclusive = false // Keep MainScreen in the backstack
                        }
                        // A more specific popUp can be used if you know the route
                        // popUpTo(PracticeDestinations.MULTILEVEL_HUB) { inclusive = true }
                    }
                }
            )
        }
        composable(
            route = AppDestinations.MULTILEVEL_RESULT_ROUTE,
            arguments = listOf(navArgument("resultId") { type = NavType.StringType })
        ) {
            MultilevelResultScreen(onNavigateBack = { navController.popBackStack() })
        }
    }
}

package com.typosbro.multilevel.ui.component


import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Divider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun DividerWithText(
    text: String,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Divider(modifier = Modifier.weight(1f))
        Text(
            text = text,
            style = MaterialTheme.typography.labelMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            modifier = Modifier.padding(horizontal = 8.dp)
        )
        Divider(modifier = Modifier.weight(1f))
    }
}

package com.typosbro.multilevel.ui.component


import androidx.compose.animation.AnimatedContent
import androidx.compose.animation.ExperimentalAnimationApi
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import com.typosbro.multilevel.R

@OptIn(ExperimentalAnimationApi::class)
@Composable
fun GoogleSignInButton(
    onClick: () -> Unit,
    isLoading: Boolean = false
) {
    OutlinedButton(
        onClick = onClick,
        modifier = Modifier.fillMaxWidth(),
        shape = MaterialTheme.shapes.medium,
        colors = ButtonDefaults.outlinedButtonColors(
            containerColor = MaterialTheme.colorScheme.surface,
            contentColor = MaterialTheme.colorScheme.onSurface
        ),
        border = ButtonDefaults.outlinedButtonBorder.copy(
            width = 1.dp, // Or use BorderStroke(1.dp, MaterialTheme.colorScheme.outline)
        ),
        enabled = !isLoading
    ) {
        AnimatedContent(
            targetState = isLoading,
            label = "GoogleButtonContent"
        ) { loading ->
            if (loading) {
                CircularProgressIndicator(
                    modifier = Modifier.size(20.dp),
                    strokeWidth = 2.dp,
                    color = MaterialTheme.colorScheme.primary
                )
            } else {
                Row(
                    modifier = Modifier.padding(vertical = 4.dp),
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.Center
                ) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_google_logo),
                        contentDescription = stringResource(id = R.string.logo_google_description),
                        modifier = Modifier.size(20.dp),
                        tint = Color.Unspecified // Use original colors of the vector
                    )
                    Spacer(modifier = Modifier.width(12.dp))
                    Text(
                        text = stringResource(id = R.string.login_google),
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        }
    }
}

package com.typosbro.multilevel.ui.component

import android.util.Log
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import coil3.compose.AsyncImage
import coil3.request.ImageRequest
import coil3.request.crossfade

@Composable
fun ImageLoader(
    imageUrl: String?,
    contentDescription: String,
    modifier: Modifier = Modifier
) {
    var isLoading by remember { mutableStateOf(true) }
    var hasError by remember { mutableStateOf(false) }

    Log.d("AsyncImage", "Loading image: $imageUrl")

    AsyncImage(
        model = ImageRequest.Builder(LocalContext.current)
            .data(imageUrl)
            .crossfade(true)
            .listener(
                onStart = {
                    isLoading = true
                    hasError = false
                    Log.d("AsyncImage", "Started loading: $imageUrl")
                },
                onSuccess = { _, _ ->
                    isLoading = false
                    Log.d("AsyncImage", "Successfully loaded: $imageUrl")
                },
                onError = { _, error ->
                    isLoading = false
                    hasError = true
                    Log.e("AsyncImage", "Failed to load: $imageUrl", error.throwable)
                }
            )
            .build(),
        contentDescription = contentDescription,
        modifier = modifier,
        contentScale = ContentScale.Fit,

        )
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/ui/component/LifecycleHandler.kt

package com.typosbro.multilevel.ui.component

import android.app.Activity
import android.view.WindowManager
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.ui.platform.LocalContext
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.compose.LocalLifecycleOwner

/**
 * A reusable composable that manages crucial lifecycle events for an active exam.
 * 1. Keeps the screen on to prevent it from dimming or sleeping.
 * 2. Listens for the ON_STOP lifecycle event (e.g., user presses power button,
 *    switches app) and invokes the provided [onStop] callback.
 *
 * @param onStop A lambda function to be executed when the screen/app is stopped.
 */
@Composable
fun HandleAppLifecycle(onStop: () -> Unit) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    DisposableEffect(lifecycleOwner) {
        // Find the window of the current activity
        val window = (context as? Activity)?.window

        // 1. Add the FLAG_KEEP_SCREEN_ON to prevent the screen from sleeping
        window?.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)

        // 2. Create and register a lifecycle observer
        val observer = LifecycleEventObserver { _, event ->
            if (event == Lifecycle.Event.ON_STOP) {
                // When the app is stopped, call the provided lambda
                onStop()
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)

        // Cleanup logic that runs when the composable leaves the screen
        onDispose {
            // 1. Clear the flag to allow the screen to sleep normally again
            window?.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
            // 2. Remove the observer to prevent memory leaks
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/ui/component/RecognitionControls.kt
package com.typosbro.multilevel.ui.component


import androidx.compose.animation.AnimatedContent
import androidx.compose.animation.scaleIn
import androidx.compose.animation.scaleOut
import androidx.compose.animation.togetherWith
import androidx.compose.foundation.layout.size
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Mic
import androidx.compose.material.icons.filled.Stop
import androidx.compose.material3.FilledIconButton
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButtonDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import com.typosbro.multilevel.R

/**
 * UI component for the recognition controls with animated recording indicator
 */

@Composable
fun RecognitionControls(
    isRecording: Boolean,
    onStartRecording: () -> Unit,
    onStopRecording: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true // Add the enabled parameter
) {
    // Animate between the start and stop buttons
    AnimatedContent(
        targetState = isRecording,
        transitionSpec = {
            scaleIn() togetherWith scaleOut()
        },
        label = "RecognitionControlButton"
    ) { recording ->
        if (recording) {
            // Stop Button
            FilledIconButton(
                onClick = onStopRecording,
                modifier = modifier.size(64.dp),
                // The button is only clickable if the parent says it's enabled.
                enabled = enabled,
                colors = IconButtonDefaults.filledIconButtonColors(
                    containerColor = MaterialTheme.colorScheme.errorContainer
                )
            ) {
                Icon(
                    imageVector = Icons.Default.Stop,
                    contentDescription = stringResource(id = R.string.recording_stop),
                    modifier = Modifier.size(32.dp)
                )
            }
        } else {
            // Start Button
            FilledIconButton(
                onClick = onStartRecording,
                modifier = modifier.size(64.dp),
                // The button is only clickable if the parent says it's enabled.
                enabled = enabled
            ) {
                Icon(
                    imageVector = Icons.Default.Mic,
                    contentDescription = stringResource(id = R.string.recording_start),
                    modifier = Modifier.size(32.dp)
                )
            }
        }
    }
}

package com.typosbro.multilevel.ui.screens.auth

import android.content.Intent
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.core.net.toUri
import androidx.hilt.navigation.compose.hiltViewModel
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import com.google.android.gms.common.api.ApiException
import com.typosbro.multilevel.R
import com.typosbro.multilevel.ui.component.DividerWithText
import com.typosbro.multilevel.ui.component.GoogleSignInButton
import com.typosbro.multilevel.ui.viewmodels.AuthViewModel
import com.typosbro.multilevel.ui.viewmodels.UiState

@Composable
fun LoginScreen(
    authViewModel: AuthViewModel = hiltViewModel()
) {
    // --- State Management ---
    val googleSignInState by authViewModel.googleSignInState.collectAsState()
    // You might have a state for when the app is waiting for the deep link token verification
    // val deepLinkVerifyState by authViewModel.deepLinkVerifyState.collectAsState()
    val isLoading =
        googleSignInState is UiState.Loading // || deepLinkVerifyState is UiState.Loading

    // --- Google Sign-In Setup ---
    val context = LocalContext.current
    val googleWebClientId = stringResource(R.string.google_web_client_id)
    val googleErrorText = stringResource(id = R.string.login_google_error)

    val googleSignInClient = remember {
        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
            .requestIdToken(googleWebClientId)
            .requestEmail()
            .build()
        GoogleSignIn.getClient(context, gso)
    }

    val googleSignInLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.StartActivityForResult()
    ) { result ->
        val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)
        try {
            val account = task.getResult(ApiException::class.java)
            account.idToken?.let { authViewModel.signInWithGoogle(it) }
        } catch (e: ApiException) {
            Log.w("LoginScreen", "Google sign in failed", e)
            authViewModel.setGoogleSignInError(googleErrorText)
        }
    }

    // --- UI ---
    Surface(
        modifier = Modifier.fillMaxSize(),
        color = MaterialTheme.colorScheme.background
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(horizontal = 24.dp, vertical = 32.dp),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = stringResource(id = R.string.login_title),
                style = MaterialTheme.typography.headlineLarge
            )
            Text(
                text = stringResource(id = R.string.login_subtitle),
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                textAlign = TextAlign.Center
            )
            Spacer(modifier = Modifier.height(48.dp))

            // --- Google Sign-In Button ---
            GoogleSignInButton(
                isLoading = googleSignInState is UiState.Loading,
                onClick = {
                    if (!isLoading) googleSignInLauncher.launch(googleSignInClient.signInIntent)
                }
            )

            Spacer(modifier = Modifier.height(24.dp))

            // --- Divider ---
            DividerWithText(
                text = stringResource(id = R.string.login_or),
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(24.dp))

            // --- Telegram Native Login Button ---
            TelegramNativeLoginButton(
                enabled = !isLoading,
                onClick = {
                    val botUsername = "milliy_technology_bot" // Your bot username
                    // This intent opens the Telegram app directly to your bot.
                    // Telegram will send a webhook to your backend when the user clicks "Start".
                    val intent = Intent(
                        Intent.ACTION_VIEW,
                        "https://t.me/$botUsername".toUri()
                    )
                    try {
                        context.startActivity(intent)
                    } catch (e: Exception) {
                        // Handle case where Telegram is not installed
                        Log.e("LoginScreen", "Failed to open Telegram", e)
                        // You could show a Toast or Snackbar message here.
                    }
                }
            )

            // --- Error Display ---
            // You would also check the deepLinkVerifyState error here in a real implementation
            val googleError = (googleSignInState as? UiState.Error)?.message
            val errorMessage = googleError

            if (errorMessage != null) {
                Spacer(modifier = Modifier.height(24.dp))
                Text(
                    text = errorMessage,
                    color = MaterialTheme.colorScheme.error,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
            }
        }
    }
}


/**
 * A custom styled button for initiating the native Telegram login flow.
 */
@Composable
private fun TelegramNativeLoginButton(
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    onClick: () -> Unit,
) {
    Button(
        onClick = onClick,
        modifier = modifier
            .fillMaxWidth()
            .height(48.dp),
        enabled = enabled,
        colors = ButtonDefaults.buttonColors(
            containerColor = Color(0xFF54A9E9), // Official Telegram Blue
            contentColor = Color.White
        )
    ) {
        Icon(
            painter = painterResource(id = R.drawable.ic_telegram_logo), // You need to add this drawable
            contentDescription = null, // decorative
            modifier = Modifier.size(24.dp),
            tint = Color.Unspecified // Icon color
        )
        Spacer(modifier = Modifier.width(12.dp))
        Text(
            text = stringResource(id = R.string.login_telegram),
            fontWeight = FontWeight.Bold
        )
    }
}

package com.typosbro.multilevel.ui.screens.practice

import android.Manifest
import android.content.pm.PackageManager
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.AnimatedContent
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.togetherWith
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarDuration
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.typosbro.multilevel.R
import com.typosbro.multilevel.data.remote.models.CueCard
import com.typosbro.multilevel.ui.component.HandleAppLifecycle
import com.typosbro.multilevel.ui.component.RecognitionControls
import com.typosbro.multilevel.ui.viewmodels.ExamPart
import com.typosbro.multilevel.ui.viewmodels.ExamUiState
import com.typosbro.multilevel.ui.viewmodels.ExamViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ExamScreen(
    onNavigateToResults: (resultId: String) -> Unit,
    viewModel: ExamViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    val context = LocalContext.current
    val snackBarHostState = remember { SnackbarHostState() }
    val coroutineScope = rememberCoroutineScope()


    HandleAppLifecycle(onStop = viewModel::stopExam)
    // --- PERMISSION HANDLING LOGIC ---
    var hasAudioPermission by remember {
        mutableStateOf(
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.RECORD_AUDIO
            ) == PackageManager.PERMISSION_GRANTED
        )
    }

    val micPermissionString = stringResource(id = R.string.permission_record_audio)
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission(),
        onResult = { isGranted ->
            hasAudioPermission = isGranted
            if (!isGranted) {
                coroutineScope.launch {
                    snackBarHostState.showSnackbar(
                        micPermissionString,
                        duration = SnackbarDuration.Long
                    )
                }
            }
        }
    )

    val requestPermission: () -> Unit = {
        permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
    }

    // [FINAL UI FIX]
    // The key for LaunchedEffect is the specific piece of data that triggers the effect.
    // This ensures the effect runs *exactly* when `finalResultId` changes from null to a value.
    LaunchedEffect(uiState.finalResultId) {
        // Add logging to confirm this block runs.
        Log.d("ExamScreen", "LaunchedEffect triggered. finalResultId is: ${uiState.finalResultId}")
        uiState.finalResultId?.let { resultId ->
            Log.d("ExamScreen", "finalResultId is not null. Navigating with: $resultId")
            onNavigateToResults(resultId)
            viewModel.onNavigationToResultConsumed()
        }
    }

    // This effect shows a snackbar when an error occurs.
    LaunchedEffect(uiState.error) {
        uiState.error?.let {
            snackBarHostState.showSnackbar(it, duration = SnackbarDuration.Long)
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        when (uiState.currentPart) {
                            ExamPart.NOT_STARTED -> "IELTS Speaking Test"
                            ExamPart.PART_1 -> "IELTS Speaking Test - Part 1"
                            ExamPart.PART_2_PREP -> "IELTS Speaking Test - Part 2 (Preparation)"
                            ExamPart.PART_2_SPEAKING -> "IELTS Speaking Test - Part 2 (Speaking)"
                            ExamPart.PART_3 -> "IELTS Speaking Test - Part 3"
                            ExamPart.FINISHED -> "IELTS Speaking Test - Finished"
                            ExamPart.ANALYSIS_COMPLETE -> "IELTS Speaking Test - Analysis"
                        }
                    )
                }
            )
        },
        snackbarHost = { SnackbarHost(snackBarHostState) }
    ) { padding ->
        Box(
            modifier = Modifier
                .padding(padding)
                .fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            AnimatedContent(
                targetState = uiState.currentPart,
                transitionSpec = {
                    fadeIn() togetherWith fadeOut()
                },
                label = "ExamPartAnimation"
            ) { targetPart ->
                val onStartRecording = {
                    if (hasAudioPermission) {
                        viewModel.startUserSpeechRecognition()
                    } else {
                        requestPermission()
                    }
                }
                val onStopRecording = { viewModel.stopUserSpeechRecognition() }

                when (targetPart) {
                    ExamPart.NOT_STARTED -> NotStartedView(onStart = {
                        if (hasAudioPermission) {
                            viewModel.startExam()
                        } else {
                            requestPermission()
                        }
                    })

                    ExamPart.PART_1 -> ExaminerInteractionView(
                        uiState = uiState,
                        onStartRecording = onStartRecording,
                        onStopRecording = onStopRecording,
                        partTitle = "Part 1: Introduction and Interview"
                    )

                    ExamPart.PART_2_PREP -> Part2PrepView(uiState)

                    ExamPart.PART_2_SPEAKING -> Part2SpeakingView(
                        uiState = uiState,
                        onStartRecording = onStartRecording,
                        onStopRecording = onStopRecording
                    )

                    ExamPart.PART_3 -> ExaminerInteractionView(
                        uiState = uiState,
                        onStartRecording = onStartRecording,
                        onStopRecording = onStopRecording,
                        partTitle = "Part 3: Discussion"
                    )

                    ExamPart.FINISHED, ExamPart.ANALYSIS_COMPLETE -> AnalysisView(uiState)
                }
            }
        }
    }
}

@Composable
fun NotStartedView(onStart: () -> Unit) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier.padding(16.dp)
    ) {
        Text(
            "Welcome to the IELTS Speaking Test",
            style = MaterialTheme.typography.headlineMedium,
            textAlign = TextAlign.Center
        )
        Spacer(Modifier.height(16.dp))
        Text(
            "This test consists of 3 parts and will take 11-14 minutes:\n\n" +
                    "• Part 1: Introduction and Interview (4-5 minutes)\n" +
                    "• Part 2: Long Turn with preparation (3-4 minutes)\n" +
                    "• Part 3: Discussion (4-5 minutes)",
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center
        )
        Spacer(Modifier.height(24.dp))
        // Explanation notice
        Text(
            text = stringResource(id = R.string.notice_english_only),
            style = MaterialTheme.typography.bodyMedium,
            textAlign = TextAlign.Center,
            color = MaterialTheme.colorScheme.primary
        )
        Spacer(Modifier.height(16.dp))
        Text(
            "Ready to begin your mock exam?",
            style = MaterialTheme.typography.titleLarge
        )
        Spacer(Modifier.height(16.dp))
        Button(onClick = onStart) {
            Text(text = "Start Exam")
        }
    }
}


@Composable
fun ExaminerInteractionView(
    uiState: ExamUiState,
    onStartRecording: () -> Unit,
    onStopRecording: () -> Unit,
    partTitle: String
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.SpaceBetween
    ) {
        // Top section with part title, timer and examiner text
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text(
                text = partTitle,
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.primary
            )

            // Show timer for Part 1 and Part 3
            if (uiState.currentPart == ExamPart.PART_1 || uiState.currentPart == ExamPart.PART_3) {
                AnimatedVisibility(visible = uiState.timerValue > 0) {
                    Text(
                        text = "Time remaining: ${formatTime(uiState.timerValue)}",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        color = if (uiState.timerValue <= 30) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
                    )
                }
            }

            Spacer(Modifier.height(16.dp))

            if (uiState.isLoading) {
                CircularProgressIndicator()
                Spacer(Modifier.height(8.dp))
                Text("Please wait...", style = MaterialTheme.typography.bodyMedium)
            } else {
                Text(
                    text = uiState.examinerMessage ?: "...",
                    style = MaterialTheme.typography.titleLarge,
                    textAlign = TextAlign.Center
                )
            }
        }

        // Bottom section with user transcription and controls
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text(
                text = uiState.partialTranscription.takeIf { it.isNotBlank() }
                    ?: if (uiState.isReadyForUserInput) "You can speak now..." else "",
                style = MaterialTheme.typography.bodyLarge,
                modifier = Modifier.heightIn(min = 48.dp),
                textAlign = TextAlign.Center,
                color = if (uiState.isRecording) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface
            )
            Spacer(Modifier.height(16.dp))

            // Show controls only when ready for user input or when recording
            AnimatedVisibility(visible = uiState.isReadyForUserInput || uiState.isRecording) {
                RecognitionControls(
                    isRecording = uiState.isRecording,
                    onStartRecording = onStartRecording,
                    onStopRecording = onStopRecording,
                    enabled = true // Always enable controls when visible
                )
            }
        }
    }
}

@Composable
fun Part2PrepView(uiState: ExamUiState) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            "Part 2: Long Turn - Preparation",
            style = MaterialTheme.typography.headlineMedium,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.primary
        )
        Spacer(Modifier.height(16.dp))

        if (uiState.isLoading) {
            CircularProgressIndicator()
            Spacer(Modifier.height(16.dp))
            Text("Getting your topic...", style = MaterialTheme.typography.bodyLarge)
        } else {
            // Display the instructions spoken by the examiner
            Text(
                text = uiState.examinerMessage ?: "You have one minute to prepare your talk.",
                style = MaterialTheme.typography.titleMedium,
                textAlign = TextAlign.Center
            )

            Spacer(Modifier.height(24.dp))

            // Preparation timer
            if (uiState.timerValue > 0) {
                Text(
                    text = formatTime(uiState.timerValue),
                    style = MaterialTheme.typography.displayLarge,
                    color = if (uiState.timerValue <= 10) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary,
                    fontWeight = FontWeight.Bold
                )
            }

            Spacer(Modifier.height(24.dp))

            // Show cue card
            uiState.part2CueCard?.let {
                CueCardView(cueCard = it)
            }
        }
    }
}

@Composable
fun Part2SpeakingView(
    uiState: ExamUiState,
    onStartRecording: () -> Unit,
    onStopRecording: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.SpaceBetween
    ) {
        // Top section with timer and cue card
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text(
                "Part 2: Long Turn - Speaking",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.primary
            )

            // Speaking timer
            AnimatedVisibility(visible = uiState.timerValue > 0) {
                Text(
                    text = "Time remaining: ${formatTime(uiState.timerValue)}",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = if (uiState.timerValue <= 30) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
                )
            }

            Spacer(Modifier.height(16.dp))

            // Show examiner message or instruction
            Text(
                text = uiState.examinerMessage
                    ?: "Please speak about your topic for up to 2 minutes.",
                style = MaterialTheme.typography.bodyLarge,
                textAlign = TextAlign.Center
            )

            Spacer(Modifier.height(16.dp))

            // Show cue card
            uiState.part2CueCard?.let {
                CueCardView(cueCard = it)
            }
        }

        // Bottom section with user transcription and controls
        Column(horizontalAlignment = Alignment.CenterHorizontally) {
            Text(
                text = uiState.partialTranscription.takeIf { it.isNotBlank() }
                    ?: if (uiState.isRecording) "Listening..." else "",
                style = MaterialTheme.typography.bodyLarge,
                modifier = Modifier.heightIn(min = 48.dp),
                textAlign = TextAlign.Center,
                color = if (uiState.isRecording) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurface
            )
            Spacer(Modifier.height(16.dp))

            // Show controls when recording (Part 2 auto-starts but user can stop)
            AnimatedVisibility(visible = uiState.isReadyForUserInput || uiState.isRecording) {
                RecognitionControls(
                    isRecording = uiState.isRecording,
                    onStartRecording = onStartRecording,
                    onStopRecording = onStopRecording,
                    enabled = true
                )
            }
        }
    }
}

@Composable
fun CueCardView(cueCard: CueCard) {
    Card(
        modifier = Modifier.padding(8.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Topic:",
                style = MaterialTheme.typography.labelLarge,
                fontWeight = FontWeight.Bold
            )
            Text(
                cueCard.topic,
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.padding(bottom = 12.dp)
            )

            Text(
                text = "You should talk about:",
                style = MaterialTheme.typography.labelLarge,
                fontWeight = FontWeight.Bold
            )
            Spacer(Modifier.height(8.dp))

            cueCard.points.forEach { point ->
                Text(
                    "• $point",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 4.dp)
                )
            }
        }
    }
}

@Composable
fun AnalysisView(uiState: ExamUiState) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center, // Center the content
        modifier = Modifier
            .fillMaxSize() // Ensure it fills the screen
            .padding(16.dp)
    ) {
        Text(
            "Exam Complete!",
            style = MaterialTheme.typography.headlineMedium,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.primary
        )
        Spacer(Modifier.height(24.dp))

        // This logic now clearly separates the different final states
        when {
            // State 1: Analysis is happening
            uiState.isLoading -> {
                Text(
                    "Analyzing your performance...",
                    style = MaterialTheme.typography.titleMedium,
                    textAlign = TextAlign.Center
                )
                Spacer(Modifier.height(16.dp))
                CircularProgressIndicator()
            }
            // State 2: Analysis failed
            uiState.error != null -> {
                Text(
                    text = "Analysis Failed",
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.error
                )
                Spacer(Modifier.height(8.dp))
                Text(
                    text = uiState.error,
                    style = MaterialTheme.typography.bodyMedium,
                    textAlign = TextAlign.Center
                )
            }
            // State 3: Analysis is done, about to navigate
            uiState.finalResultId != null -> {
                Text(
                    "Analysis complete!",
                    style = MaterialTheme.typography.titleMedium,
                    textAlign = TextAlign.Center
                )
                Spacer(Modifier.height(16.dp))
                CircularProgressIndicator() // Show a spinner to indicate action
                Spacer(Modifier.height(8.dp))
                Text("Redirecting to your results...")
            }
        }
    }
}

// Helper function to format time as MM:SS
private fun formatTime(seconds: Int): String {
    val minutes = seconds / 60
    val remainingSeconds = seconds % 60
    return String.format("%d:%02d", minutes, remainingSeconds)
}

package com.typosbro.multilevel.ui.screens.practice

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CornerSize
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material.icons.filled.SubdirectoryArrowRight
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedCard
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Tab
import androidx.compose.material3.TabRow
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontStyle
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.typosbro.multilevel.R
import com.typosbro.multilevel.data.remote.models.Criterion
import com.typosbro.multilevel.data.remote.models.ExamResultResponse
import com.typosbro.multilevel.data.remote.models.TranscriptEntry
import com.typosbro.multilevel.ui.viewmodels.ExamResultViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ExamResultScreen(
    onNavigateBack: () -> Unit,
    viewModel: ExamResultViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(text = stringResource(id = R.string.exam_result_title)) },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(
                            Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = stringResource(id = R.string.button_back)
                        )
                    }
                }
            )
        }
    ) { padding ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
        ) {
            when {
                uiState.isLoading -> {
                    CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
                }

                uiState.error != null -> {
                    Text(
                        text = stringResource(
                            id = R.string.error_message,
                            uiState.error ?: "500"
                        ),
                        color = MaterialTheme.colorScheme.error,
                        modifier = Modifier
                            .align(Alignment.Center)
                            .padding(16.dp)
                    )
                }

                uiState.result != null -> {
                    ResultDetailsContent(result = uiState.result!!)
                }
            }
        }
    }
}

@Composable
fun ResultDetailsContent(result: ExamResultResponse) {
    var selectedTabIndex by remember { mutableIntStateOf(0) }
    val feedbackString = stringResource(id = R.string.exam_result_feedback)
    val transcriptString = stringResource(id = R.string.exam_result_transcript)
    val tabs = listOf(feedbackString, transcriptString)

    Column(modifier = Modifier.fillMaxSize()) {
        OverallScoreCard(score = result.overallBand)

        TabRow(selectedTabIndex = selectedTabIndex) {
            tabs.forEachIndexed { index, title ->
                Tab(
                    selected = selectedTabIndex == index,
                    onClick = { selectedTabIndex = index },
                    text = { Text(title) }
                )
            }
        }

        when (selectedTabIndex) {
            0 -> FeedbackTab(criteria = result.criteria)
            1 -> TranscriptTab(transcript = result.transcript)
        }
    }
}

@Composable
fun OverallScoreCard(score: Double) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Text(
                text = stringResource(id = R.string.exam_result_overall),
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Spacer(Modifier.height(8.dp))
            Text(
                text = "%.1f".format(score),
                style = MaterialTheme.typography.displayLarge,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.primary
            )
        }
    }
}

@Composable
fun FeedbackTab(criteria: List<Criterion>) {
    LazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        items(criteria) { criterion ->
            CriterionCard(criterion = criterion)
        }
    }
}

@Composable
fun CriterionCard(criterion: Criterion) {
    OutlinedCard(modifier = Modifier.fillMaxWidth()) {
        Column(Modifier.padding(16.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = criterion.criterionName,
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.SemiBold,
                    modifier = Modifier.weight(1f)
                )
                Text(
                    text = "%.1f".format(criterion.bandScore),
                    style = MaterialTheme.typography.headlineSmall,
                    color = MaterialTheme.colorScheme.primary,
                    modifier = Modifier
                        .background(
                            MaterialTheme.colorScheme.primaryContainer,
                            shape = MaterialTheme.shapes.small
                        )
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                )
            }
            HorizontalDivider(Modifier.padding(vertical = 12.dp))
            Text(
                text = criterion.feedback,
                style = MaterialTheme.typography.bodyMedium,
                lineHeight = 22.sp
            )

            if (!criterion.examples.isNullOrEmpty()) {
                Spacer(Modifier.height(16.dp))
                Text(
                    text = stringResource(id = R.string.exam_result_suggestion),
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium
                )
                Spacer(Modifier.height(8.dp))
                criterion.examples.forEach { example ->
                    Column(modifier = Modifier.padding(top = 8.dp)) {
                        Text(
                            text = "\"${example.userQuote}\"",
                            style = MaterialTheme.typography.bodyMedium,
                            fontStyle = FontStyle.Italic,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                        Row(
                            verticalAlignment = Alignment.Top,
                            modifier = Modifier.padding(top = 4.dp, start = 4.dp)
                        ) {
                            Icon(
                                imageVector = Icons.Default.SubdirectoryArrowRight,
                                contentDescription = stringResource(id = R.string.exam_result_suggestion_description),
                                tint = MaterialTheme.colorScheme.tertiary,
                                modifier = Modifier.size(20.dp)
                            )
                            Spacer(Modifier.width(6.dp))
                            Text(
                                text = example.suggestion,
                                style = MaterialTheme.typography.bodyMedium
                            )
                        }
                        if (criterion.examples.last() != example) {
                            HorizontalDivider(
                                Modifier
                                    .padding(
                                        top = 12.dp,
                                        start = 8.dp,
                                        end = 8.dp
                                    )
                                    .alpha(0.2f)
                            )
                        }
                    }
                }
            }
        }
    }
}


@Composable
fun TranscriptTab(transcript: List<TranscriptEntry>) {
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp),
        reverseLayout = true
    ) {
        items(transcript.reversed()) { entry ->
            TranscriptItem(entry = entry)
        }
    }
}

@Composable
fun TranscriptItem(entry: TranscriptEntry) {
    val isUser = entry.speaker.equals("User", ignoreCase = true)
    val alignment = if (isUser) Alignment.CenterEnd else Alignment.CenterStart
    val bubbleColor =
        if (isUser) MaterialTheme.colorScheme.primaryContainer else MaterialTheme.colorScheme.surfaceVariant
    val shape =
        if (isUser) MaterialTheme.shapes.medium.copy(bottomEnd = CornerSize(0.dp)) else MaterialTheme.shapes.medium.copy(
            bottomStart = CornerSize(0.dp)
        )

    Box(
        modifier = Modifier.fillMaxWidth(),
        contentAlignment = alignment
    ) {
        Column(
            modifier = Modifier.fillMaxWidth(0.85f),
            horizontalAlignment = if (isUser) Alignment.End else Alignment.Start
        ) {
            Text(
                text = entry.speaker,
                style = MaterialTheme.typography.labelSmall,
                fontWeight = FontWeight.Bold,
                modifier = Modifier.padding(horizontal = 8.dp, vertical = 2.dp)
            )
            Card(
                shape = shape,
                colors = CardDefaults.cardColors(containerColor = bubbleColor)
            ) {
                Text(
                    text = entry.text.trim(),
                    modifier = Modifier.padding(horizontal = 12.dp, vertical = 8.dp),
                    style = MaterialTheme.typography.bodyLarge
                )
            }
        }
    }
}

package com.typosbro.multilevel.ui.screens.practice

import android.Manifest
import android.content.pm.PackageManager
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.AnimatedContent
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.togetherWith
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.core.content.ContextCompat
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.typosbro.multilevel.R
import com.typosbro.multilevel.data.remote.models.Part3Topic
import com.typosbro.multilevel.ui.component.HandleAppLifecycle
import com.typosbro.multilevel.ui.component.ImageLoader
import com.typosbro.multilevel.ui.viewmodels.MultilevelExamStage
import com.typosbro.multilevel.ui.viewmodels.MultilevelExamViewModel
import com.typosbro.multilevel.ui.viewmodels.MultilevelUiState

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MultilevelExamScreen(
    onNavigateToResults: (resultId: String) -> Unit,
    viewModel: MultilevelExamViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    val context = LocalContext.current
    val snackbarHostState = remember { SnackbarHostState() }

    HandleAppLifecycle(onStop = viewModel::stopExam)
    // --- PERMISSION HANDLING ---
    var hasAudioPermission by remember {
        mutableStateOf(
            ContextCompat.checkSelfPermission(
                context, Manifest.permission.RECORD_AUDIO
            ) == PackageManager.PERMISSION_GRANTED
        )
    }
    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission(),
        onResult = { isGranted -> hasAudioPermission = isGranted }
    )
    LaunchedEffect(Unit) {
        if (!hasAudioPermission) {
            permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
        }
    }

    // --- NAVIGATION LOGIC ---
    LaunchedEffect(uiState.finalResultId) {
        uiState.finalResultId?.let { onNavigateToResults(it) }
    }

    // --- UI ---
    Scaffold(
        topBar = { TopAppBar(title = { Text("Multilevel Speaking Test") }) },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { padding ->
        Box(
            modifier = Modifier
                .padding(padding)
                .fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            AnimatedContent(
                targetState = uiState.stage,
                transitionSpec = { fadeIn() togetherWith fadeOut() },
                label = "ExamStageAnimation"
            ) { targetStage ->
                when (targetStage) {
                    MultilevelExamStage.NOT_STARTED -> ExamStartView(onStart = {
                        if (hasAudioPermission) viewModel.startExam()
                        else permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
                    })

                    MultilevelExamStage.LOADING -> LoadingView("Downloading exam content...")
                    MultilevelExamStage.INTRO -> InstructionView(
                        instruction = stringResource(R.string.PART1_1_INTRO),
                        header = stringResource(R.string.PART1_HEADER)
                    )

                    MultilevelExamStage.PART1_2_INTRO -> InstructionView(
                        instruction = stringResource(
                            R.string.PART1_2_INTRO
                        )
                    )

                    MultilevelExamStage.PART2_INTRO -> InstructionView(
                        instruction = stringResource(R.string.PART2_INTRO),
                        header = stringResource(R.string.PART2_HEADER)
                    )

                    MultilevelExamStage.PART3_INTRO -> InstructionView(
                        instruction = stringResource(R.string.PART3_INTRO),
                        header = stringResource(R.string.PART3_HEADER)
                    )

                    MultilevelExamStage.PART1_1_QUESTION -> Part1_1_View(uiState)
                    MultilevelExamStage.PART1_2_COMPARE,
                    MultilevelExamStage.PART1_2_FOLLOWUP -> Part1_2_View(uiState)

                    MultilevelExamStage.PART2_PREP,
                    MultilevelExamStage.PART2_SPEAKING -> Part2_View(uiState)

                    MultilevelExamStage.PART3_PREP,
                    MultilevelExamStage.PART3_SPEAKING -> Part3_View(uiState)

                    MultilevelExamStage.ANALYZING -> LoadingView("Analyzing your performance...")
                    MultilevelExamStage.FINISHED_ERROR -> ErrorView(
                        uiState.error ?: "An unknown error occurred."
                    )
                }
            }
        }
    }
}

// --- Specific Views for each Exam Stage ---

@Composable
fun ExamStartView(onStart: () -> Unit) {
    Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.padding(16.dp)) {
        Text(
            "Multilevel Speaking Practice",
            style = MaterialTheme.typography.headlineSmall,
            textAlign = TextAlign.Center
        )
        Spacer(Modifier.height(16.dp))
        Text(
            "This test has 3 parts and will take approximately 15 minutes to complete. Please ensure you are in a quiet environment.",
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center
        )
        Spacer(Modifier.height(16.dp))
        Text(
            text = stringResource(id = R.string.notice_english_only),
            style = MaterialTheme.typography.bodyMedium,
            textAlign = TextAlign.Center,
            color = MaterialTheme.colorScheme.primary
        )
        Spacer(Modifier.height(32.dp))
        Button(onClick = onStart) {
            Text("Start Exam")
        }
    }
}


@Composable
fun LoadingView(text: String) {
    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        CircularProgressIndicator()
        Spacer(Modifier.height(16.dp))
        Text(text, style = MaterialTheme.typography.bodyLarge)
    }
}

@Composable
fun ErrorView(error: String) {
    Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.padding(16.dp)) {
        Text(
            "An Error Occurred",
            style = MaterialTheme.typography.headlineSmall,
            color = MaterialTheme.colorScheme.error
        )
        Spacer(Modifier.height(8.dp))
        Text(error, textAlign = TextAlign.Center)
    }
}


@Composable
fun InstructionView(instruction: String, header: String? = null) {
    Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.padding(16.dp)) {
        if (header != null) {
            Text(
                header,
                style = MaterialTheme.typography.titleLarge,
                textAlign = TextAlign.Center
            )
            Spacer(Modifier.height(16.dp))
        }
        Text(
            text = instruction,
            style = MaterialTheme.typography.titleMedium,
            textAlign = TextAlign.Center
        )
    }
}

@Composable
fun Part1_1_View(uiState: MultilevelUiState) {
    Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.padding(16.dp)) {
        Text("Part 1: Personal Questions", style = MaterialTheme.typography.titleLarge)
        Spacer(Modifier.height(32.dp))
        Text(
            uiState.currentQuestionText ?: "...",
            style = MaterialTheme.typography.headlineMedium,
            textAlign = TextAlign.Center
        )
        Spacer(Modifier.height(32.dp))
        TimerAndRecordingIndicator(uiState)
    }
}

@Composable
fun Part1_2_View(uiState: MultilevelUiState) {
    val content = uiState.examContent?.part1_2

    Column(horizontalAlignment = Alignment.CenterHorizontally, modifier = Modifier.padding(16.dp)) {
        Text("Part 1: Picture Comparison", style = MaterialTheme.typography.titleLarge)
        Spacer(Modifier.height(16.dp))
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .height(100.dp),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            ImageLoader(
                content?.image1Url,
                contentDescription = "Image 1",
                modifier = Modifier
                    .weight(1f)
                    .clip(RoundedCornerShape(8.dp)),
            )
            ImageLoader(
                content?.image2Url,
                contentDescription = "Image 2",
                modifier = Modifier
                    .weight(1f)
                    .clip(RoundedCornerShape(8.dp)),
            )
        }
        Spacer(Modifier.height(24.dp))
        Text(
            uiState.currentQuestionText ?: "...",
            style = MaterialTheme.typography.headlineSmall,
            textAlign = TextAlign.Center
        )
        Spacer(Modifier.height(24.dp))
        TimerAndRecordingIndicator(uiState)
    }
}

@Composable
fun Part2_View(uiState: MultilevelUiState) {
    val content = uiState.examContent?.part2


    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier
            .padding(16.dp)
            .fillMaxHeight()
            .verticalScroll(rememberScrollState())
    ) {
        Text("Part 2: Monologue", style = MaterialTheme.typography.titleLarge)
        Spacer(Modifier.height(16.dp))
        ImageLoader(
            content?.imageUrl,
            contentDescription = "Part 2 Image",
            modifier = Modifier
                .fillMaxWidth()
                .height(200.dp)
                .clip(RoundedCornerShape(8.dp)),
        )
        Spacer(Modifier.height(24.dp))
        Text(
            uiState.currentQuestionText ?: "...",
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Start,
            lineHeight = 24.sp,
            modifier = Modifier.fillMaxWidth()
        )
        Spacer(Modifier.height(24.dp))
        TimerAndRecordingIndicator(uiState)
    }
}

@Composable
fun Part3_View(uiState: MultilevelUiState) {
    val content = uiState.examContent?.part3
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        modifier = Modifier
            .padding(16.dp)
            .fillMaxHeight()
            .verticalScroll(rememberScrollState())
    ) {
        Text("Part 3: Argument", style = MaterialTheme.typography.titleLarge)
        Spacer(Modifier.height(16.dp))
        if (content != null) {
            Part3CueCard(content)
        }
        Spacer(Modifier.height(24.dp))
        TimerAndRecordingIndicator(uiState)
    }
}

@Composable
fun Part3CueCard(topic: Part3Topic) {
    Card(modifier = Modifier.fillMaxWidth()) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                topic.topic,
                style = MaterialTheme.typography.titleLarge,
                textAlign = TextAlign.Center,
                modifier = Modifier.fillMaxWidth()
            )
            Spacer(Modifier.height(16.dp))
            Row(horizontalArrangement = Arrangement.spacedBy(16.dp)) {
                Column(Modifier.weight(1f)) {
                    Text(
                        "FOR",
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.primary
                    )
                    topic.forPoints.forEach {
                        Text(
                            "• $it",
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }
                Column(Modifier.weight(1f)) {
                    Text(
                        "AGAINST",
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.error
                    )
                    topic.againstPoints.forEach {
                        Text(
                            "• $it",
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }
            }
        }
    }
}


@Composable
fun TimerAndRecordingIndicator(uiState: MultilevelUiState) {
    val stage = uiState.stage
    val isPrep = stage == MultilevelExamStage.PART2_PREP || stage == MultilevelExamStage.PART3_PREP

    Column(horizontalAlignment = Alignment.CenterHorizontally) {
        if (uiState.timerValue > 0) {
            Text(
                if (isPrep) "Preparation Time" else "Time Remaining",
                style = MaterialTheme.typography.titleMedium
            )
            Text(
                formatTime(uiState.timerValue),
                style = MaterialTheme.typography.displayMedium,
                fontWeight = FontWeight.Bold,
                color = if (uiState.timerValue <= 10) MaterialTheme.colorScheme.error else MaterialTheme.colorScheme.primary
            )
        }
        Spacer(Modifier.height(16.dp))
        if (uiState.isRecording) {
            Text(
                "RECORDING",
                color = Color.Red,
                fontWeight = FontWeight.Bold,
                letterSpacing = 2.sp
            )
        }
    }
}

private fun formatTime(seconds: Int): String {
    val minutes = seconds / 60
    val remainingSeconds = seconds % 60
    return String.format("%02d:%02d", minutes, remainingSeconds)
}

package com.typosbro.multilevel.ui.screens.practice

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Card
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import com.typosbro.multilevel.R

// Enum to define the practice parts for type safety
enum class PracticePart(val title: String, val description: String) {
    FULL("Full Mock Exam", "A complete 3-part speaking simulation."),
    P1_1("Part 1.1 Practice", "Answer personal questions."),
    P1_2("Part 1.2 Practice", "Compare and contrast two pictures."),
    P2("Part 2 Practice", "Deliver a monologue based on a cue card."),
    P3("Part 3 Practice", "Discuss and argue a given topic.")
}


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MultilevelPracticeHubScreen(
    onNavigateBack: () -> Unit,
    onPartSelected: (PracticePart) -> Unit,
) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(text = "Multilevel Practice") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(
                            Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = stringResource(id = R.string.button_back)
                        )
                    }
                }
            )
        }
    ) { padding ->
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            modifier = Modifier
                .padding(padding)
                .fillMaxSize()
                .verticalScroll(rememberScrollState()),
        ) {
            PracticePart.entries.forEach { part ->
                PracticePartCard(
                    title = part.title,
                    description = part.description,
                    onClick = { onPartSelected(part) }
                )
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun PracticePartCard(title: String, description: String, onClick: () -> Unit) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        onClick = onClick
    ) {
        Column(Modifier.padding(24.dp)) {
            Text(
                text = title,
                style = MaterialTheme.typography.headlineSmall
            )
            Text(
                text = description,
                style = MaterialTheme.typography.bodyMedium
            )
        }
    }
}

package com.typosbro.multilevel.ui.screens.practice

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedCard
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Tab
import androidx.compose.material3.TabRow
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.typosbro.multilevel.R
import com.typosbro.multilevel.data.remote.models.FeedbackBreakdown
import com.typosbro.multilevel.data.remote.models.MultilevelExamResultResponse
import com.typosbro.multilevel.ui.viewmodels.MultilevelResultViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MultilevelResultScreen(
    onNavigateBack: () -> Unit,
    viewModel: MultilevelResultViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(text = stringResource(id = R.string.exam_result_title)) },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(
                            Icons.AutoMirrored.Filled.ArrowBack,
                            contentDescription = stringResource(id = R.string.button_back)
                        )
                    }
                }
            )
        }
    ) { padding ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
        ) {
            when {
                uiState.isLoading -> CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
                uiState.error != null -> ErrorView(uiState.error!!) // Reusing ErrorView from ExamScreen
                uiState.result != null -> MultilevelResultContent(result = uiState.result!!)
            }
        }
    }
}

@Composable
fun MultilevelResultContent(result: MultilevelExamResultResponse) {
    var selectedTabIndex by remember { mutableIntStateOf(0) }
    val feedbackString = stringResource(id = R.string.exam_result_feedback)
    val transcriptString = stringResource(id = R.string.exam_result_transcript)
    val tabs = listOf(feedbackString, transcriptString)

    // Check if this is a result for a single part or a full exam
    val isSinglePartResult = result.feedbackBreakdown.size == 1

    Column(modifier = Modifier.fillMaxSize()) {
        OverallScoreCardMultilevel(
            score = result.totalScore,
            maxScore = if (isSinglePartResult) null else 72,
            isSinglePart = isSinglePartResult
        )

        TabRow(selectedTabIndex = selectedTabIndex) {
            tabs.forEachIndexed { index, title ->
                Tab(
                    selected = selectedTabIndex == index,
                    onClick = { selectedTabIndex = index },
                    text = { Text(title) }
                )
            }
        }

        when (selectedTabIndex) {
            0 -> FeedbackTabMultilevel(feedbackBreakdown = result.feedbackBreakdown)
            1 -> TranscriptTab(transcript = result.transcript)
        }
    }
}

@Composable
fun OverallScoreCardMultilevel(score: Int, maxScore: Int?, isSinglePart: Boolean) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
        ) {
            Text(
                text = if (isSinglePart) stringResource(R.string.exam_result_part_score) else stringResource(
                    R.string.exam_result_overall
                ),
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Spacer(Modifier.height(8.dp))
            Row(verticalAlignment = Alignment.Bottom) {
                Text(
                    text = "$score",
                    style = MaterialTheme.typography.displayLarge,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                )
                // Only show the max score if it's provided (for the full exam)
                if (maxScore != null) {
                    Text(
                        text = " / $maxScore",
                        style = MaterialTheme.typography.headlineSmall,
                        fontWeight = FontWeight.Light,
                        modifier = Modifier.padding(bottom = 6.dp)
                    )
                }
            }
        }
    }
}

@Composable
fun FeedbackTabMultilevel(feedbackBreakdown: List<FeedbackBreakdown>) {
    LazyColumn(
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        items(feedbackBreakdown) { feedback ->
            FeedbackPartCard(feedback = feedback)
        }
    }
}

@Composable
fun FeedbackPartCard(feedback: FeedbackBreakdown) {
    OutlinedCard(modifier = Modifier.fillMaxWidth()) {
        Column(Modifier.padding(16.dp)) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = feedback.part,
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.SemiBold
                )
                Text(
                    text = "${feedback.score}",
                    style = MaterialTheme.typography.headlineSmall,
                    color = MaterialTheme.colorScheme.primary,
                    modifier = Modifier
                        .background(
                            MaterialTheme.colorScheme.primaryContainer,
                            shape = MaterialTheme.shapes.small
                        )
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                )
            }
            HorizontalDivider(Modifier.padding(vertical = 12.dp))
            Text(
                text = feedback.feedback,
                style = MaterialTheme.typography.bodyMedium,
                lineHeight = 22.sp
            )
        }
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/ui/screens/practice/PracticeHubScreen.kt
package com.typosbro.multilevel.ui.screens.practice

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Card
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import com.typosbro.multilevel.R

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PracticeHubScreen(
    onNavigateToIELTS: () -> Unit,
    onNavigateToMultilevel: () -> Unit
) {
    Scaffold(
        topBar = { TopAppBar(title = { Text(text = stringResource(id = R.string.practice_hub_title)) }) }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .fillMaxSize(),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                onClick = onNavigateToMultilevel // Navigate to the full exam
            ) {
                Column(Modifier.padding(24.dp)) {
                    Text(
                        text = stringResource(id = R.string.practice_hub_multilevel),
                        style = MaterialTheme.typography.headlineSmall
                    )
                    Text(
                        text = stringResource(id = R.string.practice_hub_multilevel_description),
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }

            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                onClick = onNavigateToIELTS // Navigate to the full exam
            ) {
                Column(Modifier.padding(24.dp)) {
                    Text(
                        text = stringResource(id = R.string.practice_hub_ielts),
                        style = MaterialTheme.typography.headlineSmall
                    )
                    Text(
                        text = stringResource(id = R.string.practice_hub_ielts_description),
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }
        }
    }
}

package com.typosbro.multilevel.ui.screens.profile

import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.size
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import com.typosbro.multilevel.R
import com.typosbro.multilevel.utils.getAppVersion

@Composable
fun AboutAppDialog(
    onDismiss: () -> Unit
) {
    val context = LocalContext.current
    val appVersion = remember { getAppVersion(context) }

    AlertDialog(
        onDismissRequest = onDismiss,
        // Use your app's icon
        icon = {
            Image(
                painter = painterResource(id = R.drawable.ic_launcher_round),
                contentDescription = stringResource(id = R.string.logo_app),
                modifier = Modifier.size(48.dp)
            )
        },
        title = { Text(text = stringResource(id = R.string.about_title)) },
        text = {
            Column {
                Text(
                    text = stringResource(id = R.string.about_subtitle),
                    style = MaterialTheme.typography.bodyMedium
                )
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = stringResource(id = R.string.about_version, appVersion),
                    style = MaterialTheme.typography.bodySmall
                )
                Text(
                    text = "© 2025 TyposBro",
                    style = MaterialTheme.typography.bodySmall
                )
            }
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text(text = stringResource(R.string.button_ok))
            }
        }
    )
}

package com.typosbro.multilevel.ui.screens.profile

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ExitToApp
import androidx.compose.material.icons.automirrored.filled.HelpOutline
import androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight
import androidx.compose.material.icons.filled.AccountCircle
import androidx.compose.material.icons.filled.DarkMode
import androidx.compose.material.icons.filled.Event
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.Language
import androidx.compose.material.icons.filled.PrivacyTip
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.material.icons.filled.Warning
import androidx.compose.material.icons.filled.WorkspacePremium
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ListItem
import androidx.compose.material3.ListItemDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.typosbro.multilevel.R
import com.typosbro.multilevel.ui.viewmodels.AuthViewModel
import com.typosbro.multilevel.ui.viewmodels.ProfileViewModel
import com.typosbro.multilevel.ui.viewmodels.SettingsViewModel
import com.typosbro.multilevel.ui.viewmodels.UiState
import com.typosbro.multilevel.utils.openUrlInCustomTab
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProfileScreen(
    profileViewModel: ProfileViewModel = hiltViewModel(),
    authViewModel: AuthViewModel = hiltViewModel(),
    settingsViewModel: SettingsViewModel = hiltViewModel()
) {
    val uiState by profileViewModel.uiState.collectAsStateWithLifecycle()
    val userProfile = uiState.userProfile

    val isDarkTheme by settingsViewModel.isDarkTheme.collectAsStateWithLifecycle()
    val currentLanguageCode by settingsViewModel.currentLanguageCode.collectAsStateWithLifecycle()

    // --- State for Dialogs ---
    var showLogoutDialog by remember { mutableStateOf(false) }
    var showDeleteDialog by remember { mutableStateOf(false) }
    var showAboutDialog by remember { mutableStateOf(false) }
    var showLanguageDialog by remember { mutableStateOf(false) }
    val coroutineScope = rememberCoroutineScope()
    val context = LocalContext.current

    val privacyPolicyUrl = stringResource(R.string.url_privacy_policy)
    val faqUrl = stringResource(R.string.url_faq)

    LaunchedEffect(uiState.deleteState) {
        if (uiState.deleteState is UiState.Success) {
            coroutineScope.launch {
                authViewModel.logout()
            }
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(text = stringResource(id = R.string.profile_title)) },
                actions = {
                    IconButton(
                        onClick = { profileViewModel.fetchUserProfile() },
                        enabled = !uiState.isLoading
                    ) {
                        Icon(
                            Icons.Default.Refresh,
                            contentDescription = stringResource(id = R.string.button_refresh)
                        )
                    }
                }
            )
        }
    ) { padding ->

        if (uiState.isLoading && userProfile == null) {
            Box(
                Modifier
                    .fillMaxSize()
                    .padding(padding), contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
            return@Scaffold
        }

        LazyColumn(
            modifier = Modifier
                .padding(padding)
                .fillMaxSize()
        ) {
            // --- Account Section ---
            item {
                SectionHeader(title = stringResource(id = R.string.profile_section_title_account))
                // --- CORRECTED: Use the new display fields from UserProfileViewData ---
                ListItem(
                    headlineContent = { Text(text = userProfile?.displayName ?: "...") },
                    supportingContent = { Text(userProfile?.primaryIdentifier ?: "...") },
                    leadingContent = {
                        Icon(
                            Icons.Default.AccountCircle,
                            contentDescription = "User Profile"
                        )
                    }
                )
                ListItem(
                    headlineContent = { Text(text = "Authentication Method") },
                    supportingContent = { Text(userProfile?.authProvider ?: "...") },
                    leadingContent = {
                        when (userProfile?.authProvider?.lowercase()) {
                            "google" -> Icon(
                                painter = painterResource(id = R.drawable.ic_google_logo),
                                contentDescription = "Google Login",
                                modifier = Modifier.size(24.dp),
                                tint = Color.Unspecified // Use default color
                            )

                            "telegram" -> Icon(
                                painter = painterResource(id = R.drawable.ic_telegram_logo),
                                contentDescription = "Telegram Login",
                                modifier = Modifier.size(24.dp),
                                tint = Color.Unspecified // Use default color
                            )

                            else -> Icon(
                                imageVector = Icons.Default.PrivacyTip,
                                contentDescription = "Default Login Method"
                            )
                        }
                    }
                )
                ListItem(
                    headlineContent = { Text(text = stringResource(id = R.string.profile_item_membership)) },
                    supportingContent = { Text(userProfile?.registeredDate ?: "...") },
                    leadingContent = {
                        Icon(
                            Icons.Default.Event,
                            contentDescription = stringResource(id = R.string.profile_item_membership)
                        )
                    }
                )
                ListItem(
                    headlineContent = {
                        Text(
                            text = stringResource(id = R.string.profile_item_subscription),
                            fontWeight = FontWeight.SemiBold
                        )
                    },
                    supportingContent = { Text(text = stringResource(id = R.string.tier_free)) },
                    leadingContent = {
                        Icon(
                            Icons.Default.WorkspacePremium,
                            contentDescription = stringResource(id = R.string.profile_item_subscription)
                        )
                    },
                    trailingContent = {
                        Icon(
                            Icons.AutoMirrored.Filled.KeyboardArrowRight,
                            contentDescription = null
                        )
                    },
                    modifier = Modifier.clickable { /* TODO: Navigate to subscription screen */ }
                )
            }

            // --- Settings Section ---
            item {
                SectionHeader(title = stringResource(id = R.string.profile_section_title_settings))
                ListItem(
                    headlineContent = { Text(text = stringResource(id = R.string.profile_item_dark_mode)) },
                    leadingContent = {
                        Icon(
                            Icons.Default.DarkMode,
                            contentDescription = stringResource(id = R.string.profile_item_dark_mode)
                        )
                    },
                    trailingContent = {
                        Switch(
                            checked = isDarkTheme,
                            onCheckedChange = { isChecked ->
                                settingsViewModel.onThemeChanged(isChecked)
                            }
                        )
                    }
                )
                ListItem(
                    headlineContent = { Text(text = stringResource(id = R.string.profile_item_language)) },
                    leadingContent = {
                        Icon(
                            Icons.Default.Language,
                            contentDescription = stringResource(id = R.string.profile_item_language)
                        )
                    },
                    trailingContent = {
                        Row(verticalAlignment = Alignment.CenterVertically) {
                            Text(
                                text = (currentLanguageCode ?: "en").uppercase(),
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                            Icon(
                                Icons.AutoMirrored.Filled.KeyboardArrowRight,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    },
                    modifier = Modifier.clickable { showLanguageDialog = true }
                )
            }

            // --- Support Section ---
            item {
                SectionHeader(title = stringResource(id = R.string.profile_section_title_support))
                ListItem(
                    headlineContent = { Text(text = stringResource(id = R.string.profile_item_help)) },
                    leadingContent = {
                        Icon(
                            Icons.AutoMirrored.Filled.HelpOutline,
                            contentDescription = stringResource(id = R.string.profile_item_help)
                        )
                    },
                    modifier = Modifier.clickable { openUrlInCustomTab(context, faqUrl) }
                )
                ListItem(
                    headlineContent = { Text(text = stringResource(id = R.string.profile_item_privacy)) },
                    leadingContent = {
                        Icon(
                            Icons.Default.PrivacyTip,
                            contentDescription = stringResource(id = R.string.profile_item_privacy)
                        )
                    },
                    modifier = Modifier.clickable { openUrlInCustomTab(context, privacyPolicyUrl) }
                )

                ListItem(
                    headlineContent = { Text(text = stringResource(id = R.string.profile_item_about)) },
                    leadingContent = {
                        Icon(
                            Icons.Default.Info,
                            contentDescription = stringResource(id = R.string.profile_item_about)
                        )
                    },
                    modifier = Modifier.clickable { showAboutDialog = true }
                )
            }

            // --- Actions Section ---
            item {
                SectionHeader(title = stringResource(id = R.string.profile_section_title_action))
                ListItem(
                    headlineContent = { Text(text = stringResource(id = R.string.button_logout)) },
                    leadingContent = {
                        Icon(
                            Icons.AutoMirrored.Filled.ExitToApp,
                            contentDescription = stringResource(id = R.string.button_logout)
                        )
                    },
                    modifier = Modifier.clickable { showLogoutDialog = true }
                )
                ListItem(
                    headlineContent = {
                        Text(
                            text = stringResource(id = R.string.profile_item_delete),
                            color = MaterialTheme.colorScheme.error
                        )
                    },
                    supportingContent = { Text(text = stringResource(id = R.string.profile_item_subtitle_permanent)) },
                    leadingContent = {
                        Icon(
                            Icons.Default.Warning,
                            contentDescription = stringResource(id = R.string.profile_item_delete),
                            tint = MaterialTheme.colorScheme.error
                        )
                    },
                    modifier = Modifier.clickable { showDeleteDialog = true }
                )
                Spacer(Modifier.height(32.dp))
            }
        }

        // --- Error Message Display ---
        val deleteError = (uiState.deleteState as? UiState.Error)?.message
        val fetchError = uiState.error
        val errorMessage = deleteError ?: fetchError

        errorMessage?.let {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(bottom = 80.dp),
                contentAlignment = Alignment.BottomCenter
            ) {
                Text(it, color = MaterialTheme.colorScheme.error)
            }
        }
    }

    // --- DIALOGS ---
    if (showLogoutDialog) {
        LogoutConfirmationDialog(
            onConfirm = {
                showLogoutDialog = false
                coroutineScope.launch {
                    authViewModel.logout()
                }
            },
            onDismiss = { showLogoutDialog = false }
        )
    }

    if (showDeleteDialog) {
        DeleteAccountConfirmationDialog(
            isLoading = uiState.deleteState is UiState.Loading,
            onConfirm = {
                profileViewModel.deleteAccount()
            },
            onDismiss = {
                if (uiState.deleteState !is UiState.Loading) {
                    showDeleteDialog = false
                    profileViewModel.resetDeleteState()
                }
            }
        )
    }

    // Add this to your composable to prevent showing multiple dialogs
    if (showAboutDialog) {
        AboutAppDialog(onDismiss = { showAboutDialog = false })
    }

    if (showLanguageDialog) {
        LanguageSelectionDialog(
            onLanguageSelected = { languageCode ->
                settingsViewModel.onLanguageChanged(languageCode)
                showLanguageDialog = false
            },
            onDismiss = { showLanguageDialog = false }
        )
    }
}


@Composable
private fun SectionHeader(title: String) {
    Column {
        HorizontalDivider()
        Text(
            text = title.uppercase(),
            style = MaterialTheme.typography.labelSmall,
            modifier = Modifier.padding(horizontal = 16.dp, vertical = 8.dp)
        )
    }
}

@Composable
private fun LogoutConfirmationDialog(onConfirm: () -> Unit, onDismiss: () -> Unit) {
    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(text = stringResource(id = R.string.logout_confirm_title)) },
        text = { Text(text = stringResource(id = R.string.logout_confirm_subtitle)) },
        confirmButton = {
            Button(onClick = onConfirm) { Text(text = stringResource(id = R.string.button_logout)) }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) { Text(text = stringResource(id = R.string.button_cancel)) }
        }
    )
}

@Composable
private fun DeleteAccountConfirmationDialog(
    isLoading: Boolean,
    onConfirm: () -> Unit,
    onDismiss: () -> Unit
) {
    AlertDialog(
        onDismissRequest = onDismiss,
        icon = {
            Icon(
                Icons.Default.Warning,
                contentDescription = stringResource(id = R.string.button_warning),
                tint = MaterialTheme.colorScheme.error
            )
        },
        title = { Text(text = stringResource(id = R.string.delete_confirm_title)) },
        text = { Text(text = stringResource(id = R.string.delete_confirm_subtitle)) },
        confirmButton = {
            Button(
                onClick = onConfirm,
                enabled = !isLoading,
                colors = ButtonDefaults.buttonColors(containerColor = MaterialTheme.colorScheme.error)
            ) {
                if (isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(24.dp),
                        color = MaterialTheme.colorScheme.onError
                    )
                } else {
                    Text(text = stringResource(id = R.string.delete_permanent))
                }
            }
        },
        dismissButton = {
            TextButton(
                onClick = onDismiss,
                enabled = !isLoading
            ) { Text(text = stringResource(id = R.string.button_cancel)) }
        }
    )
}

@Composable
private fun LanguageSelectionDialog(
    onLanguageSelected: (String) -> Unit,
    onDismiss: () -> Unit
) {
    val supportedLanguages = mapOf(
        "en" to "English",
        "ru" to "Русский",
        "uz" to "O'zbekcha"
    )

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text(stringResource(id = R.string.language_dialog_title)) },
        text = {
            Column {
                supportedLanguages.forEach { (code, name) ->
                    ListItem(
                        headlineContent = { Text(name) },
                        modifier = Modifier.clickable { onLanguageSelected(code) },
                        colors = ListItemDefaults.colors(containerColor = Color.Transparent)
                    )
                }
            }
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text(stringResource(id = R.string.button_cancel))
            }
        }
    )
}

package com.typosbro.multilevel.ui.screens.progress

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.KeyboardArrowRight
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.ListItem
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SegmentedButton
import androidx.compose.material3.SegmentedButtonDefaults
import androidx.compose.material3.SingleChoiceSegmentedButtonRow
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.typosbro.multilevel.R
import com.typosbro.multilevel.ui.viewmodels.ExamType
import com.typosbro.multilevel.ui.viewmodels.GenericExamResultSummary
import com.typosbro.multilevel.ui.viewmodels.ProgressViewModel
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

// A sensible order for displaying the practice part tabs
private val multilevelPartOrder = listOf("FULL", "P1_1", "P1_2", "P2", "P3")

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ProgressScreen(
    onNavigateToIeltsResult: (resultId: String) -> Unit,
    onNavigateToMultilevelResult: (resultId: String) -> Unit,
    viewModel: ProgressViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    // UPDATED: Logic to get the correct list based on main tab and sub-tab
    val currentHistory = when (uiState.selectedTab) {
        ExamType.IELTS -> uiState.ieltsHistory
        ExamType.MULTILEVEL -> uiState.multilevelHistory[uiState.selectedMultilevelPart]
            ?: emptyList()
    }

    // A helper map to define max scores for the chart
    val multilevelMaxScores = mapOf(
        "FULL" to 72.0, "P1_1" to 12.0, "P1_2" to 12.0, "P2" to 24.0, "P3" to 24.0
    )
    val yMaxForChart = when (uiState.selectedTab) {
        ExamType.IELTS -> 9.0
        ExamType.MULTILEVEL -> multilevelMaxScores[uiState.selectedMultilevelPart] ?: 72.0
    }

    Scaffold(topBar = { TopAppBar(title = { Text(text = stringResource(id = R.string.progress_title)) }) }) { padding ->
        Column(modifier = Modifier.padding(padding)) {
            ExamTypeSwitcher(
                selectedType = uiState.selectedTab,
                onTypeSelected = { viewModel.selectTab(it) },
                modifier = Modifier.fillMaxWidth()
            )

            // NEW: Conditionally show the Multilevel part switcher
            if (uiState.selectedTab == ExamType.MULTILEVEL && uiState.multilevelHistory.isNotEmpty()) {
                MultilevelPartSwitcher(
                    availableParts = uiState.multilevelHistory.keys,
                    selectedPart = uiState.selectedMultilevelPart,
                    onPartSelected = { viewModel.selectMultilevelPart(it) }
                )
            }

            if (uiState.isLoading) {
                Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator()
                }
            } else if (currentHistory.isEmpty()) {
                Box(Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    Text(
                        text = stringResource(id = R.string.progress_empty),
                        modifier = Modifier.padding(16.dp)
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier.fillMaxSize(),
                    contentPadding = PaddingValues(vertical = 16.dp)
                ) {
                    item {
                        Text(
                            text = stringResource(id = R.string.progress_score),
                            style = MaterialTheme.typography.titleLarge,
                            modifier = Modifier.padding(horizontal = 16.dp)
                        )
                        Spacer(Modifier.height(8.dp))
                        ScoreHistoryChart(
                            scores = currentHistory.map { it.score },
                            yMax = yMaxForChart, // Use dynamic max value
                            modifier = Modifier
                                .fillMaxWidth()
                                .height(200.dp)
                                .padding(16.dp)
                        )
                    }

                    item {
                        Text(
                            text = stringResource(id = R.string.progress_history),
                            style = MaterialTheme.typography.titleLarge,
                            modifier = Modifier.padding(
                                start = 16.dp,
                                end = 16.dp,
                                top = 24.dp,
                                bottom = 8.dp
                            )
                        )
                    }
                    items(currentHistory) { result ->
                        ExamHistoryItem(result = result, onClick = {
                            when (result.type) {
                                ExamType.IELTS -> onNavigateToIeltsResult(result.id)
                                ExamType.MULTILEVEL -> onNavigateToMultilevelResult(result.id)
                            }
                        })
                        HorizontalDivider(Modifier.padding(horizontal = 16.dp))
                    }
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MultilevelPartSwitcher(
    availableParts: Set<String>,
    selectedPart: String,
    onPartSelected: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    // Filter and order the parts that actually have history data
    val partsToShow = multilevelPartOrder.filter { it in availableParts }

    if (partsToShow.size > 1) {
        SingleChoiceSegmentedButtonRow(
            modifier = modifier
                .fillMaxWidth()
                .padding(horizontal = 16.dp, vertical = 8.dp)
        ) {
            partsToShow.forEachIndexed { index, part ->
                SegmentedButton(
                    selected = part == selectedPart,
                    onClick = { onPartSelected(part) },
                    shape = SegmentedButtonDefaults.itemShape(
                        index = index,
                        count = partsToShow.size
                    ),
                ) {
                    // Make labels more user-friendly
                    val label = when (part) {
                        "FULL" -> "Full"
                        "P1_1" -> "1.1"
                        "P1_2" -> "1.2"
                        "P2" -> "2"
                        "P3" -> "3"
                        else -> part
                    }
                    Text(label)
                }
            }
        }
    }
}


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ExamTypeSwitcher(
    selectedType: ExamType,
    onTypeSelected: (ExamType) -> Unit,
    modifier: Modifier = Modifier
) {
    SingleChoiceSegmentedButtonRow(
        modifier = modifier.padding(
            horizontal = 16.dp,
            vertical = 8.dp
        )
    ) {
        SegmentedButton(
            selected = selectedType == ExamType.MULTILEVEL,
            onClick = { onTypeSelected(ExamType.MULTILEVEL) },
            shape = SegmentedButtonDefaults.itemShape(index = 0, count = 2),
        ) {
            Text("Multilevel")
        }
        SegmentedButton(
            selected = selectedType == ExamType.IELTS,
            onClick = { onTypeSelected(ExamType.IELTS) },
            shape = SegmentedButtonDefaults.itemShape(index = 1, count = 2),

            ) {
            Text("IELTS")
        }
    }
}

@Composable
fun ExamHistoryItem(result: GenericExamResultSummary, onClick: () -> Unit) {
    val dateFormatter = remember { SimpleDateFormat("MMM dd, yyyy", Locale.getDefault()) }

    ListItem(
        headlineContent = { Text(result.scoreLabel, fontWeight = FontWeight.SemiBold) },
        supportingContent = { Text(dateFormatter.format(Date(result.examDate))) },
        trailingContent = {
            Icon(
                Icons.AutoMirrored.Filled.KeyboardArrowRight,
                contentDescription = stringResource(id = R.string.progress_detail)
            )
        },
        modifier = Modifier.clickable(onClick = onClick)
    )
}

@Composable
fun ScoreHistoryChart(scores: List<Double>, yMax: Double, modifier: Modifier = Modifier) {
    if (scores.size < 2) {
        Box(modifier = modifier, contentAlignment = Alignment.Center) {
            Text(text = stringResource(id = R.string.progress_no_enough_data))
        }
        return
    }

    val primaryColor = MaterialTheme.colorScheme.primary

    Canvas(modifier = modifier) {
        val xStep = if (scores.size > 1) size.width / (scores.size - 1) else 0f
        val yMin = 0.0

        val path = Path()
        scores.reversed().forEachIndexed { index, score ->
            val x = index * xStep
            val y = size.height - ((score - yMin) / (yMax - yMin) * size.height).toFloat()
            val clampedY = y.coerceIn(0f, size.height)

            if (index == 0) {
                path.moveTo(x, clampedY)
            } else {
                path.lineTo(x, clampedY)
            }
            drawCircle(color = primaryColor, radius = 8f, center = Offset(x, clampedY))
        }

        drawPath(
            path = path,
            color = primaryColor,
            style = Stroke(width = 5f, cap = StrokeCap.Round)
        )
    }
}

package com.typosbro.multilevel.ui.screens.wordbank

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ListItem
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.typosbro.multilevel.ui.viewmodels.WordBankViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ExploreLevelScreen(
    onLevelSelected: (String) -> Unit,
    onNavigateBack: () -> Unit,
    viewModel: WordBankViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    LaunchedEffect(Unit) {
        viewModel.fetchExploreLevels()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Explore Levels") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .padding(paddingValues)
                .fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            if (uiState.isLoading && uiState.exploreLevels.isEmpty()) {
                CircularProgressIndicator()
            } else {
                LazyColumn(modifier = Modifier.fillMaxSize()) {
                    items(uiState.exploreLevels, key = { it }) { level ->
                        ListItem(
                            headlineContent = {
                                Text(
                                    text = level,
                                    style = MaterialTheme.typography.titleLarge
                                )
                            },
                            modifier = Modifier.clickable { onLevelSelected(level) },
                            trailingContent = {
                                val isLoadingItem = level in uiState.loadingItems
                                val isAdded = uiState.exploreLevelsAddedStatus[level] == true

                                // --- REVISED: Show a different button based on 'isAdded' status ---
                                if (isAdded) {
                                    // Show a "Remove" button if the level is already added
                                    OutlinedButton(
                                        onClick = { viewModel.removeWordsByLevel(level) },
                                        enabled = !isLoadingItem
                                    ) {
                                        if (isLoadingItem) {
                                            CircularProgressIndicator(Modifier.size(24.dp))
                                        } else {
                                            Text("Remove")
                                        }
                                    }
                                } else {
                                    // Show an "Add" button if the level is not added
                                    Button(
                                        onClick = { viewModel.addWordsByLevel(level) },
                                        enabled = !isLoadingItem
                                    ) {
                                        if (isLoadingItem) {
                                            CircularProgressIndicator(
                                                modifier = Modifier.size(24.dp),
                                                color = MaterialTheme.colorScheme.onPrimary
                                            )
                                        } else {
                                            Text("Add")
                                        }
                                    }
                                }
                            }
                        )
                        Divider()
                    }
                }
            }
        }
    }
}

package com.typosbro.multilevel.ui.screens.wordbank

import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.ListItem
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.typosbro.multilevel.ui.viewmodels.WordBankViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ExploreTopicScreen(
    level: String,
    onNavigateBack: () -> Unit,
    viewModel: WordBankViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    LaunchedEffect(level) {
        viewModel.fetchExploreTopics(level)
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Topics for $level") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .padding(paddingValues)
                .fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            if (uiState.isLoading && uiState.exploreTopics.isEmpty()) {
                CircularProgressIndicator()
            } else {
                LazyColumn(modifier = Modifier.fillMaxSize()) {
                    items(uiState.exploreTopics, key = { it }) { topic ->
                        ListItem(
                            headlineContent = {
                                Text(
                                    topic,
                                    style = MaterialTheme.typography.titleMedium
                                )
                            },
                            trailingContent = {
                                val loadingKey = "${level}_$topic"
                                val isLoadingItem = loadingKey in uiState.loadingItems
                                val isAdded = uiState.exploreTopicAddedStatus[topic] == true

                                // --- REVISED: Show a different button based on 'isAdded' status ---
                                if (isAdded) {
                                    // Show a "Remove" button if the topic is already added
                                    OutlinedButton(
                                        onClick = { viewModel.removeWordsByTopic(level, topic) },
                                        enabled = !isLoadingItem
                                    ) {
                                        if (isLoadingItem) {
                                            CircularProgressIndicator(Modifier.size(24.dp))
                                        } else {
                                            Text("Remove")
                                        }
                                    }
                                } else {
                                    // Show an "Add" button if the topic is not added
                                    Button(
                                        onClick = { viewModel.addWordsByTopic(level, topic) },
                                        enabled = !isLoadingItem
                                    ) {
                                        if (isLoadingItem) {
                                            CircularProgressIndicator(
                                                Modifier.size(24.dp),
                                                color = MaterialTheme.colorScheme.onPrimary,
                                                strokeWidth = 2.dp
                                            )
                                        } else {
                                            Text("Add")
                                        }
                                    }
                                }
                            }
                        )
                        Divider()
                    }
                }
            }
        }
    }
}

package com.typosbro.multilevel.ui.screens.wordbank

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ChevronRight
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.typosbro.multilevel.ui.viewmodels.DeckInfo
import com.typosbro.multilevel.ui.viewmodels.WordBankViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun WordBankScreen(
    onNavigateToReview: () -> Unit,
    onNavigateToExplore: () -> Unit,
    viewModel: WordBankViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    var expandedLevels by remember { mutableStateOf(setOf<String>()) }

    val lifecycleOwner = LocalLifecycleOwner.current
    DisposableEffect(lifecycleOwner) {
        val observer = object : DefaultLifecycleObserver {
            override fun onResume(owner: LifecycleOwner) {
                viewModel.loadDeckHierarchy()
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }

    Scaffold(
        topBar = { TopAppBar(title = { Text("Decks") }) }
    ) { padding ->
        Column(modifier = Modifier.padding(padding)) {
            StatsBar(
                due = uiState.totalDue,
                new = uiState.totalNew,
                total = uiState.totalWords
            )

            // This Box will now correctly contain either the loader or the weighted list.
            Box(modifier = Modifier.weight(1f)) { // --- FIX 1: Give this Box the weight ---
                if (uiState.isLoading && uiState.deckHierarchy.isEmpty()) {
                    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                        CircularProgressIndicator()
                    }
                } else {
                    // --- FIX 2: Remove fillMaxSize() from here, the weight modifier handles it ---
                    LazyColumn {
                        items(uiState.deckHierarchy, key = { it.name }) { levelDeck ->
                            Column {
                                DeckItemRow(
                                    deck = levelDeck,
                                    isExpanded = levelDeck.name in expandedLevels,
                                    onExpandToggle = { isNowExpanded ->
                                        expandedLevels = if (isNowExpanded) {
                                            expandedLevels + levelDeck.name
                                        } else {
                                            expandedLevels - levelDeck.name
                                        }
                                    },
                                    onReviewClick = {
                                        if (levelDeck.dueCount > 0) {
                                            viewModel.startReviewSession(level = levelDeck.level)
                                            onNavigateToReview()
                                        }
                                    }
                                )

                                AnimatedVisibility(visible = levelDeck.name in expandedLevels) {
                                    Column {
                                        levelDeck.subDecks.forEach { topicDeck ->
                                            DeckItemRow(
                                                deck = topicDeck,
                                                isSubItem = true,
                                                onReviewClick = {
                                                    if (topicDeck.dueCount > 0) {
                                                        viewModel.startReviewSession(
                                                            level = topicDeck.level,
                                                            topic = topicDeck.topic
                                                        )
                                                        onNavigateToReview()
                                                    }
                                                }
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // --- FIX 3: Remove the Spacer. The weight on the Box above handles this now. ---

            // This button will now correctly appear at the bottom.
            OutlinedButton(
                onClick = onNavigateToExplore,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(horizontal = 16.dp, vertical = 8.dp)
            ) {
                Text("Explore New Words")
            }
        }
    }
}

// StatsBar, DeckItemRow, and CountBadge composables remain unchanged.
@Composable
private fun StatsBar(due: Int, new: Int, total: Int) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp),
        horizontalArrangement = Arrangement.Center,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(text = "Due: ", fontWeight = FontWeight.Bold)
        Text(text = "$due", color = Color(0xFF4CAF50), fontWeight = FontWeight.Bold)
        Spacer(Modifier.width(16.dp))
        Text(text = "New: ", fontWeight = FontWeight.Bold)
        Text(text = "$new", color = Color(0xFF42A5F5), fontWeight = FontWeight.Bold)
        Spacer(Modifier.width(16.dp))
        Text(text = "Total: ", fontWeight = FontWeight.Bold)
        Text(text = "$total", color = Color(0xFFFFA726), fontWeight = FontWeight.Bold)
    }
}

@Composable
private fun DeckItemRow(
    deck: DeckInfo,
    isExpanded: Boolean = false,
    isSubItem: Boolean = false,
    onExpandToggle: ((Boolean) -> Unit)? = null,
    onReviewClick: () -> Unit
) {
    val isClickable = deck.dueCount > 0
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(enabled = isClickable, onClick = onReviewClick)
            .padding(
                start = if (isSubItem) 32.dp else 16.dp,
                end = 16.dp,
                top = 12.dp,
                bottom = 12.dp
            ),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        if (onExpandToggle != null) {
            Icon(
                imageVector = if (isExpanded) Icons.Default.KeyboardArrowDown else Icons.Default.ChevronRight,
                contentDescription = if (isExpanded) "Collapse" else "Expand",
                modifier = Modifier.clickable { onExpandToggle(!isExpanded) }
            )
        } else {
            Spacer(Modifier.width(24.dp))
        }

        Text(
            text = deck.name,
            style = MaterialTheme.typography.bodyLarge,
            modifier = Modifier.weight(1f),
            color = if (isClickable) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurface.copy(
                alpha = 0.6f
            )
        )

        CountBadge(count = deck.dueCount, color = Color(0xFF4CAF50))
        CountBadge(count = deck.newCount, color = Color(0xFF42A5F5))
        CountBadge(count = deck.totalCount, color = Color(0xFFFFA726))
    }
}

@Composable
private fun CountBadge(count: Int, color: Color) {
    Box(
        modifier = Modifier
            .width(40.dp)
            .clip(RoundedCornerShape(8.dp))
            .background(color.copy(alpha = if (count > 0) 1f else 0.3f)),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = count.toString(),
            color = Color.White,
            fontSize = 12.sp,
            fontWeight = FontWeight.Bold,
            modifier = Modifier.padding(vertical = 4.dp)
        )
    }
}

package com.typosbro.multilevel.ui.screens.wordbank

import androidx.compose.animation.core.animateFloatAsState
import androidx.compose.animation.core.tween
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.aspectRatio
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.alexstyl.swipeablecard.ExperimentalSwipeableCardApi
import com.typosbro.multilevel.data.local.WordEntity
import com.typosbro.multilevel.features.srs.ReviewQuality
import com.typosbro.multilevel.ui.viewmodels.WordBankViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun WordReviewScreen(
    onNavigateBack: () -> Unit,
    viewModel: WordBankViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    val currentWord = uiState.currentWord

    LaunchedEffect(Unit) {
        viewModel.startReviewSession()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Review Session") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.AutoMirrored.Filled.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { padding ->
        Box(
            modifier = Modifier
                .padding(padding)
                .fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            if (uiState.isSessionFinished) {
                SessionComplete(onNavigateBack)
            } else if (uiState.isSessionActive && currentWord == null) {
                CircularProgressIndicator()
            } else if (uiState.isSessionActive && currentWord != null) {
                val scope = rememberCoroutineScope()

                fun onReview(quality: ReviewQuality) {
                    viewModel.handleReview(currentWord, quality)
                }

                Column(
                    modifier = Modifier.fillMaxSize(),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(
                        20.dp,
                        alignment = Alignment.CenterVertically
                    )
                ) {
                    Box(
                        modifier = Modifier
                            .weight(1f)
                            .fillMaxWidth(),
                        contentAlignment = Alignment.Center
                    ) {
                        WordReviewCard(
                            word = currentWord,
                        )
                    }

                    // --- NEW: 2x2 Grid Layout for Buttons ---
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(horizontal = 24.dp, vertical = 16.dp),
                        verticalArrangement = Arrangement.spacedBy(12.dp),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        // Top Row: Again, Hard
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            ReviewButton(
                                text = "Again",
                                color = MaterialTheme.colorScheme.error,
                                modifier = Modifier.weight(1f)
                            ) {
                                scope.launch { onReview(ReviewQuality.AGAIN) }
                            }
                            ReviewButton(
                                text = "Hard",
                                color = Color(0xFFFFA726),
                                modifier = Modifier.weight(1f)
                            ) {
                                scope.launch { onReview(ReviewQuality.HARD) }
                            }
                        }
                        // Bottom Row: Good, Easy
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(16.dp)
                        ) {
                            ReviewButton(
                                text = "Good",
                                color = Color(0xFF42A5F5),
                                modifier = Modifier.weight(1f)
                            ) {
                                scope.launch { onReview(ReviewQuality.GOOD) }
                            }
                            ReviewButton(
                                text = "Easy",
                                color = Color(0xFF66BB6A),
                                modifier = Modifier.weight(1f)
                            ) {
                                scope.launch { onReview(ReviewQuality.EASY) }
                            }
                        }
                    }
                }
            } else {
                Text(
                    "No words to review right now. Come back later!",
                    textAlign = TextAlign.Center,
                    modifier = Modifier.padding(16.dp)
                )
            }
        }
    }
}

// --- UPDATED: Helper for larger, more readable buttons ---
@Composable
private fun ReviewButton(
    text: String,
    color: Color,
    modifier: Modifier = Modifier,
    onClick: () -> Unit
) {
    Button(
        onClick = onClick,
        modifier = modifier.height(56.dp), // Increased height for better tap target
        colors = ButtonDefaults.buttonColors(containerColor = color)
    ) {
        Text(
            text = text,
            style = MaterialTheme.typography.bodyLarge, // Larger font
            fontWeight = FontWeight.Bold // Bolder font
        )
    }
}


@OptIn(ExperimentalSwipeableCardApi::class)
@Composable
fun WordReviewCard(
    word: WordEntity,
) {
    var isRevealed by remember { mutableStateOf(false) }

    // When a new word is displayed, reset the revealed state
    LaunchedEffect(word) {
        isRevealed = false
    }

    Box(
        Modifier
            .fillMaxWidth(0.9f)
            .aspectRatio(3f / 4f)
    ) {
        // Our new FlippableCard handles the rotation and content switching
        FlippableCard(
            isFlipped = isRevealed,
            onClick = { isRevealed = !isRevealed },
            front = {
                // Content for the front of the card
                CardContent(
                    title = word.word,
                    titleStyle = MaterialTheme.typography.displayMedium,
                    example = word.example1,

                    )
            },
            back = {
                // Content for the back of the card
                CardContent(
                    title = word.translation,
                    titleStyle = MaterialTheme.typography.headlineMedium,
                    titleColor = MaterialTheme.colorScheme.primary,
                    example = word.example1Translation
                )
            }
        )
    }
}

/**
 * A reusable composable that shows a card with a front and back that can be flipped.
 */
@Composable
fun FlippableCard(
    isFlipped: Boolean,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    front: @Composable () -> Unit,
    back: @Composable () -> Unit,
) {
    // Animate the rotationY value between 0f (front) and 180f (back)
    val rotation by animateFloatAsState(
        targetValue = if (isFlipped) 180f else 0f,
        animationSpec = tween(durationMillis = 500),
        label = "cardFlipRotation"
    )

    Card(
        onClick = onClick,
        modifier = modifier
            .fillMaxSize()
            // Apply the animated rotation to the graphics layer
            .graphicsLayer {
                rotationY = rotation
                // Add a perspective effect
                cameraDistance = 12 * density
            }
    ) {
        // Show the back of the card if the rotation is past 90 degrees, otherwise show the front.
        // The back is also rotated so it's not mirrored.
        if (rotation <= 90f) {
            Box(Modifier.fillMaxSize()) {
                front()
            }
        } else {
            Box(
                Modifier
                    .fillMaxSize()
                    // Rotate the back content so it's facing the correct way
                    .graphicsLayer { rotationY = 180f }
            ) {
                back()
            }
        }
    }
}

/**
 * A generic composable for displaying content inside the review card.
 * Used for both the front and back sides.
 */
@Composable
private fun CardContent(
    title: String,
    titleStyle: androidx.compose.ui.text.TextStyle,
    titleColor: Color = MaterialTheme.colorScheme.onSurface,
    example: String? = null,
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(
            text = title,
            style = titleStyle,
            color = titleColor,
            textAlign = TextAlign.Center
        )

        if (example != null) {
            Spacer(Modifier.height(32.dp))
            Column(horizontalAlignment = Alignment.CenterHorizontally) {
                Text(
                    text = "e.g. $example",
                    style = MaterialTheme.typography.bodyLarge,
                    textAlign = TextAlign.Center
                )
            }
        }
    }
}

@Composable
fun SessionComplete(onNavigateBack: () -> Unit) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center,
        modifier = Modifier.padding(32.dp)
    ) {
        Text("Great job!", style = MaterialTheme.typography.headlineLarge)
        Text("You've finished your review session.", style = MaterialTheme.typography.bodyLarge)
        Spacer(Modifier.height(24.dp))
        Button(onClick = onNavigateBack) {
            Text("Go back")
        }
    }
}

package com.typosbro.multilevel.ui.screens

import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.History
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.MenuBook
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.Icon
import androidx.compose.material3.NavigationBar
import androidx.compose.material3.NavigationBarItem
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.navigation.NavDestination.Companion.hierarchy
import androidx.navigation.NavGraph.Companion.findStartDestination
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument
import androidx.navigation.navigation
import com.typosbro.multilevel.R
import com.typosbro.multilevel.ui.screens.practice.MultilevelPracticeHubScreen
import com.typosbro.multilevel.ui.screens.practice.PracticeHubScreen
import com.typosbro.multilevel.ui.screens.profile.ProfileScreen
import com.typosbro.multilevel.ui.screens.progress.ProgressScreen
import com.typosbro.multilevel.ui.screens.wordbank.ExploreLevelScreen
import com.typosbro.multilevel.ui.screens.wordbank.ExploreTopicScreen
import com.typosbro.multilevel.ui.screens.wordbank.WordBankScreen
import com.typosbro.multilevel.ui.screens.wordbank.WordReviewScreen

object MainDestinations {
    const val PRACTICE_ROUTE = "practice"
    const val WORDBANK_ROUTE = "wordbank"
    const val PROGRESS_ROUTE = "progress"
    const val PROFILE_ROUTE = "profile"
}

object WordBankDestinations {
    const val HUB_ROUTE = "wordbank_hub"
    const val REVIEW_ROUTE = "wordbank_review"
    const val EXPLORE_LEVEL_ROUTE = "wordbank_explore_level"
    const val EXPLORE_TOPIC_ROUTE = "wordbank_explore_topic/{level}"
}

object PracticeDestinations {
    const val PRACTICE_HUB = "practice_hub"
    const val MULTILEVEL_HUB = "multilevel_hub"
    // IELTS hub could be added here later
}

@Composable
fun MainScreen(
    onNavigateToIELTS: () -> Unit,
    onNavigateToMultilevel: (String) -> Unit,
    onNavigateToIeltsResult: (resultId: String) -> Unit,
    onNavigateToMultilevelResult: (resultId: String) -> Unit,
) {
    val mainNavController = rememberNavController()
    Scaffold(
        bottomBar = {
            BottomNavigationBar(navController = mainNavController)
        }
    ) { innerPadding ->
        NavHost(
            navController = mainNavController,
            startDestination = MainDestinations.PRACTICE_ROUTE,
            modifier = Modifier.padding(innerPadding)
        ) {
            // UPDATED: Wrap practice screens in a nested graph
            navigation(
                startDestination = PracticeDestinations.PRACTICE_HUB,
                route = MainDestinations.PRACTICE_ROUTE
            ) {
                composable(PracticeDestinations.PRACTICE_HUB) {
                    PracticeHubScreen(
                        onNavigateToIELTS = onNavigateToIELTS,
                        onNavigateToMultilevel = {
                            // Navigate to the new hub screen
                            mainNavController.navigate(PracticeDestinations.MULTILEVEL_HUB)
                        }
                    )
                }
                composable(PracticeDestinations.MULTILEVEL_HUB) {
                    MultilevelPracticeHubScreen(
                        onNavigateBack = { mainNavController.popBackStack() },
                        onPartSelected = { practicePart ->
                            // Use the enum's name as the navigation argument
                            onNavigateToMultilevel(practicePart.name)
                        }
                    )
                }
            }

            navigation(
                startDestination = WordBankDestinations.HUB_ROUTE,
                route = MainDestinations.WORDBANK_ROUTE
            ) {
                composable(WordBankDestinations.HUB_ROUTE) {
                    WordBankScreen(
                        onNavigateToReview = {
                            mainNavController.navigate(WordBankDestinations.REVIEW_ROUTE)
                        },
                        onNavigateToExplore = {
                            mainNavController.navigate(WordBankDestinations.EXPLORE_LEVEL_ROUTE)
                        }
                    )
                }
                composable(WordBankDestinations.REVIEW_ROUTE) {
                    WordReviewScreen(
                        onNavigateBack = { mainNavController.popBackStack() }
                    )
                }
                composable(WordBankDestinations.EXPLORE_LEVEL_ROUTE) {
                    ExploreLevelScreen(
                        onLevelSelected = { level ->
                            mainNavController.navigate("wordbank_explore_topic/$level")
                        },
                        onNavigateBack = { mainNavController.popBackStack() }
                    )
                }
                composable(
                    route = WordBankDestinations.EXPLORE_TOPIC_ROUTE,
                    arguments = listOf(navArgument("level") { type = NavType.StringType })
                ) { backStackEntry ->
                    ExploreTopicScreen(
                        level = backStackEntry.arguments?.getString("level") ?: "",
                        onNavigateBack = { mainNavController.popBackStack() }
                    )
                }
            }

            composable(MainDestinations.PROGRESS_ROUTE) {
                ProgressScreen(
                    onNavigateToIeltsResult = onNavigateToIeltsResult,
                    onNavigateToMultilevelResult = onNavigateToMultilevelResult
                )
            }
            composable(MainDestinations.PROFILE_ROUTE) {
                ProfileScreen()
            }
        }
    }
}

@Composable
fun BottomNavigationBar(navController: NavHostController) {
    val practiceString = stringResource(id = R.string.navbar_practice)
    val vocabularyString = stringResource(id = R.string.navbar_vocabulary)
    val progressString = stringResource(id = R.string.navbar_progress)
    val profileString = stringResource(id = R.string.navbar_profile)

    val items = listOf(
        Triple(practiceString, Icons.Default.Home, MainDestinations.PRACTICE_ROUTE),
        Triple(vocabularyString, Icons.Default.MenuBook, MainDestinations.WORDBANK_ROUTE),
        Triple(progressString, Icons.Default.History, MainDestinations.PROGRESS_ROUTE),
        Triple(profileString, Icons.Default.Person, MainDestinations.PROFILE_ROUTE)
    )

    NavigationBar {
        val navBackStackEntry by navController.currentBackStackEntryAsState()
        val currentDestination = navBackStackEntry?.destination

        items.forEach { item ->
            val route = item.third
            NavigationBarItem(
                icon = { Icon(item.second, contentDescription = item.first) },
                label = { Text(item.first) },
                selected = currentDestination?.hierarchy?.any { it.route == route } == true,
                onClick = {
                    navController.navigate(route) {
                        popUpTo(navController.graph.findStartDestination().id) { saveState = true }
                        launchSingleTop = true
                        restoreState = true
                    }
                }
            )
        }
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/ui/theme/Color.kt
package com.typosbro.multilevel.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)
// Logo color: #0074d9
// Logo background: #ffffff

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/ui/theme/Theme.kt
package com.typosbro.multilevel.ui.theme

import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext

// --- New Colors for accessibility buttons ---
val SuccessGreen = Color(0xFF4CAF50)
val SuccessGreenDark = Color(0xFF81C784)
val FailureRed = Color(0xFFD32F2F)
val FailureRedDark = Color(0xFFE57373)
// -----------------------------------------

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40

    /* Other default colors to override
    background = Color(0xFFFFFBFE),
    surface = Color(0xFFFFFBFE),
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF1C1B1F),
    onSurface = Color(0xFF1C1B1F),
    */
)

@Composable
fun MultilevelTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    // Dynamic color is available on Android 12+
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}
// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/ui/theme/Type.kt
package com.typosbro.multilevel.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

// Set of Material typography styles to start with
val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
    /* Other default text styles to override
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
    */
)

package com.typosbro.multilevel.ui.viewmodels

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.typosbro.multilevel.data.local.SessionManager
import com.typosbro.multilevel.data.remote.models.AuthResponse
import com.typosbro.multilevel.data.remote.models.GoogleSignInRequest
import com.typosbro.multilevel.data.remote.models.OneTimeTokenRequest
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import com.typosbro.multilevel.data.repositories.AuthRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import javax.inject.Inject

@HiltViewModel
class AuthViewModel @Inject constructor(
    private val authRepository: AuthRepository,
    private val sessionManager: SessionManager
) : ViewModel() {

    // --- REMOVED: _loginState and _registrationState ---

    // --- State holder for Google Sign-In ---
    private val _googleSignInState = MutableStateFlow<UiState<AuthResponse>>(UiState.Idle)
    val googleSignInState = _googleSignInState.asStateFlow()

    // --- NEW: State holder for the Telegram Deep Link verification process ---
    private val _deepLinkVerifyState = MutableStateFlow<UiState<AuthResponse>>(UiState.Idle)
    val deepLinkVerifyState = _deepLinkVerifyState.asStateFlow()


    fun signInWithGoogle(idToken: String) {
        viewModelScope.launch {
            _googleSignInState.value = UiState.Loading
            val result = authRepository.googleSignIn(GoogleSignInRequest(idToken))
            when (result) {
                is RepositoryResult.Success -> {
                    sessionManager.updateToken(result.data.token)
                    _googleSignInState.value = UiState.Success(result.data)
                }

                is RepositoryResult.Error -> {
                    _googleSignInState.value = UiState.Error(result.message)
                }
            }
        }
    }

    /**
     * Verifies the one-time token received from the Telegram deep link.
     * This is called from MainActivity when a deep link is detected.
     */
    fun verifyOneTimeToken(token: String) {
        // Prevent re-triggering if already loading/successful
        if (_deepLinkVerifyState.value is UiState.Loading || _deepLinkVerifyState.value is UiState.Success) return

        viewModelScope.launch {
            _deepLinkVerifyState.value = UiState.Loading
            val result = authRepository.verifyTelegramToken(OneTimeTokenRequest(token))
            when (result) {
                is RepositoryResult.Success -> {
                    sessionManager.updateToken(result.data.token)
                    _deepLinkVerifyState.value = UiState.Success(result.data)
                }

                is RepositoryResult.Error -> {
                    _deepLinkVerifyState.value = UiState.Error(result.message)
                }
            }
        }
    }


    /**
     * Allows the UI to report a client-side error from the Google Sign-In flow,
     * such as the user canceling the dialog.
     */
    fun setGoogleSignInError(message: String) {
        _googleSignInState.value = UiState.Error(message)
    }

    /**
     * Resets all authentication states to Idle. This is useful for clearing errors.
     */
    fun resetAllStates() {
        _googleSignInState.value = UiState.Idle
        _deepLinkVerifyState.value = UiState.Idle
    }

    // This method is still useful for your AppNavigation to get a handle on the session manager
    fun getSessionManager(): SessionManager {
        return sessionManager
    }

    /**
     * Logs the user out by clearing the token from the SessionManager.
     */
    suspend fun logout() {
        withContext(Dispatchers.IO) {
            sessionManager.logout()
            resetAllStates() // Also reset UI states on logout
        }
    }
}
// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/ui/viewmodels/BaseViewModel.kt
package com.typosbro.multilevel.ui.viewmodels
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

// Simple base for common loading/error state
open class BaseViewModel : ViewModel() {
    protected val _isLoading = MutableStateFlow(false)
    val isLoading = _isLoading.asStateFlow()

    protected val _error = MutableStateFlow<String?>(null)
    val error = _error.asStateFlow() // Expose error state

    // Function to clear error message (e.g., when user dismisses it)
    fun clearError() {
        _error.value = null
    }

    // Helper to run suspending functions with loading/error handling
    protected fun <T> launchDataLoad(
        block: suspend () -> RepositoryResult<T>,
        onSuccess: (T) -> Unit
    ) {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null // Clear previous error
            when (val result = block()) {
                is RepositoryResult.Success -> onSuccess(result.data)
                is RepositoryResult.Error -> _error.value = result.message
            }
            _isLoading.value = false
        }
    }
    // Overload for actions that don't need specific success data handling
    protected fun launchAction(
        block: suspend () -> RepositoryResult<*>,
        onComplete: (() -> Unit)? = null // Optional completion callback
    ) {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            when (val result = block()) {
                is RepositoryResult.Success -> { /* Action succeeded */ }
                is RepositoryResult.Error -> _error.value = result.message
            }
            _isLoading.value = false
            onComplete?.invoke() // Call completion callback if provided
        }
    }
}

// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/ui/viewmodels/ExamResultViewModel.kt
package com.typosbro.multilevel.ui.viewmodels

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.typosbro.multilevel.data.remote.models.ExamResultResponse
import com.typosbro.multilevel.data.repositories.ChatRepository
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ExamResultUiState(
    val isLoading: Boolean = true,
    val error: String? = null,
    val result: ExamResultResponse? = null
)

@HiltViewModel
class ExamResultViewModel @Inject constructor(
    private val repository: ChatRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _uiState = MutableStateFlow(ExamResultUiState())
    val uiState: StateFlow<ExamResultUiState> = _uiState.asStateFlow()

    private val resultId: String = checkNotNull(savedStateHandle["resultId"])

    init {
        fetchResultDetails()
    }

    private fun fetchResultDetails() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }

            // Use a 'when' expression to handle the custom RepositoryResult
            when (val result = repository.getExamResultDetails(resultId)) {
                is RepositoryResult.Success -> {
                    _uiState.update {
                        it.copy(isLoading = false, result = result.data)
                    }
                }
                is RepositoryResult.Error -> {
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            error = result.message
                        )
                    }
                }
            }
        }
    }
}

package com.typosbro.multilevel.ui.viewmodels

import android.content.Context
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.typosbro.multilevel.data.remote.models.CueCard
import com.typosbro.multilevel.data.remote.models.ExamStepRequest
import com.typosbro.multilevel.data.remote.models.ExamStepResponse
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import com.typosbro.multilevel.data.remote.models.TranscriptEntry
import com.typosbro.multilevel.data.repositories.ChatRepository
import com.typosbro.multilevel.features.whisper.Recorder
import com.typosbro.multilevel.features.whisper.engine.WhisperEngineNative
import com.typosbro.multilevel.utils.AudioPlayer
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.util.concurrent.atomic.AtomicBoolean
import javax.inject.Inject

enum class ExamPart {
    NOT_STARTED,
    PART_1,
    PART_2_PREP,
    PART_2_SPEAKING,
    PART_3,
    FINISHED,
    ANALYSIS_COMPLETE
}

data class ExamUiState(
    val currentPart: ExamPart = ExamPart.NOT_STARTED,
    val isLoading: Boolean = false,
    val isRecording: Boolean = false,
    val isReadyForUserInput: Boolean = false,
    val examinerMessage: String? = null,
    val partialTranscription: String = "",
    val part2CueCard: CueCard? = null,
    val timerValue: Int = 0,
    val finalResultId: String? = null,
    val error: String? = null
)

@HiltViewModel
class ExamViewModel @Inject constructor(
    @ApplicationContext private val context: Context,
    private val chatRepository: ChatRepository
) : ViewModel(), Recorder.RecorderListener {

    private val _uiState = MutableStateFlow(ExamUiState())
    val uiState = _uiState.asStateFlow()

    private var whisperEngine: WhisperEngineNative? = null
    private var recorder: Recorder? = null

    private var part1TimerJob: Job? = null
    private var part2PrepTimerJob: Job? = null
    private var part2SpeakingTimerJob: Job? = null
    private var part3TimerJob: Job? = null
    private var isExamFinishedByTimer = AtomicBoolean(false)
    private var shouldForcePartTransition = AtomicBoolean(false)

    private val audioDataBuffer = mutableListOf<FloatArray>()
    private val transcript = mutableListOf<TranscriptEntry>()
    private var questionCountInPart = 0
    private var audioQueue = mutableListOf<List<Int>>()
    private var isPlayingAudio = false

    companion object {
        const val PART_1_DURATION = 20 // 5 minutes
        const val PART_2_PREP_DURATION = 10 // 1 minute
        const val PART_2_SPEAKING_DURATION = 20 // 2 minutes
        const val PART_3_DURATION = 20 // 5 minutes
        const val FINAL_ANSWER_WINDOW_S = 10 // Last 10 seconds of Part 3
    }

    private fun updateState(caller: String, transform: (ExamUiState) -> ExamUiState) {
        val currentState = _uiState.value
        val newState = transform(currentState)
        _uiState.value = newState
        if (currentState != newState) {
            Log.d("STATE_UPDATE", "Caller: $caller")
            Log.d("STATE_UPDATE", "  - OLD: $currentState")
            Log.d("STATE_UPDATE", "  - NEW: $newState")
        }
    }

    init {
        viewModelScope.launch(Dispatchers.IO) {
            updateState("init") { it.copy(isLoading = true) }
            whisperEngine = WhisperEngineNative(context).also {
                val modelFile = getAssetFile("whisper-tiny.en.tflite")
                it.initialize(modelFile.absolutePath, "", false)
            }
            recorder = Recorder(context, this@ExamViewModel)
            withContext(Dispatchers.Main) {
                updateState("init_complete") { it.copy(isLoading = false) }
            }
        }
    }

    fun onNavigationToResultConsumed() {
        updateState("onNavigationToResultConsumed") { it.copy(finalResultId = null) }
    }

    override fun onDataReceived(samples: FloatArray) {
        synchronized(audioDataBuffer) {
            audioDataBuffer.add(samples)
        }
    }

    override fun onRecordingStopped() {
        viewModelScope.launch {
            Log.d("ExamViewModel", "Recording stopped. Processing collected audio.")
            transcribeBufferedAudio()
        }
    }

    private suspend fun transcribeBufferedAudio() {
        val allSamples: FloatArray
        synchronized(audioDataBuffer) {
            if (audioDataBuffer.isEmpty()) {
                handleTranscriptionResult("")
                return
            }
            allSamples = FloatArray(audioDataBuffer.sumOf { it.size })
            var destinationPos = 0
            audioDataBuffer.forEach { chunk ->
                System.arraycopy(chunk, 0, allSamples, destinationPos, chunk.size)
                destinationPos += chunk.size
            }
            audioDataBuffer.clear()
        }

        val fullTranscription = withContext(Dispatchers.Default) {
            try {
                whisperEngine?.transcribeBuffer(allSamples) ?: ""
            } catch (t: Throwable) {
                Log.e("ExamViewModel", "Whisper transcription failed", t)
                ""
            }
        }

        Log.d("ExamViewModel", "Full transcription result: '$fullTranscription'")
        updateState("transcribeBufferedAudio") { it.copy(partialTranscription = fullTranscription) }

        if (fullTranscription.isNotBlank()) {
            transcript.add(TranscriptEntry("User", fullTranscription))
        }

        handleTranscriptionResult(fullTranscription)
    }


    fun startExam() {
        if (_uiState.value.isLoading) return
        questionCountInPart = 0
        transcript.clear()
        isExamFinishedByTimer.set(false)
        cancelAllTimers()
        updateState("startExam") {
            it.copy(
                isLoading = true,
                currentPart = ExamPart.PART_1,
                examinerMessage = "Starting IELTS Speaking Test - Part 1..."
            )
        }
        startPart1Timer()
        viewModelScope.launch {
            when (val result = chatRepository.getInitialExamQuestion()) {
                is RepositoryResult.Success -> {
                    val response = result.data
                    transcript.add(TranscriptEntry("Examiner", response.examinerLine))
                    updateState("startExam_success") {
                        it.copy(
                            isLoading = false,
                            examinerMessage = response.examinerLine,
                            isReadyForUserInput = false
                        )
                    }
                    playAudioQueue(listOfNotNull(response.inputIds))
                }

                is RepositoryResult.Error -> updateState("startExam_error") {
                    it.copy(
                        isLoading = false,
                        error = result.message
                    )
                }
            }
        }
    }

    private fun startPart1Timer() {
        part1TimerJob = viewModelScope.launch {
            for (i in PART_1_DURATION downTo 1) {
                updateState("part1Timer") { it.copy(timerValue = i) }
                delay(1000)
            }
            if (_uiState.value.currentPart == ExamPart.PART_1) {
                Log.d("ExamViewModel", "Part 1 timer finished. Forcing transition to Part 2.")
                shouldForcePartTransition.set(true)
                stopCurrentAudio() // Stop any pending audio
                if (_uiState.value.isRecording) {
                    recorder?.stop() // This will trigger onRecordingStopped -> handleTranscriptionResult
                } else {
                    moveToPart2()
                }
            }
        }
    }


    private fun continueWithPart1Questions(userInput: String) {
        updateState("continueWithPart1Questions") {
            it.copy(
                isLoading = true,
                partialTranscription = ""
            )
        }
        questionCountInPart++
        val request = ExamStepRequest(
            part = 1,
            userInput = userInput,
            transcriptContext = transcript.joinToString("\n") { "${it.speaker}: ${it.text}" },
            questionCountInPart = questionCountInPart
        )
        processExamStep(request) { response ->
            if (response.examinerLine.isNotBlank()) transcript.add(
                TranscriptEntry(
                    "Examiner",
                    response.examinerLine
                )
            )
            updateState("continueWithPart1Questions_success") {
                it.copy(
                    isLoading = false,
                    examinerMessage = response.examinerLine
                )
            }
            playAudioQueue(listOfNotNull(response.inputIds))
        }
    }

    private fun moveToPart2() {
        part1TimerJob?.cancel()
        questionCountInPart = 0
        updateState("moveToPart2") {
            it.copy(
                currentPart = ExamPart.PART_2_PREP,
                examinerMessage = "Moving to Part 2...",
                isLoading = true, timerValue = 0, isRecording = false,
                isReadyForUserInput = false, partialTranscription = ""
            )
        }
        viewModelScope.launch {
            val request = ExamStepRequest(
                part = 2,
                userInput = "Moving to Part 2. Provide the standard instructions for Part 2, but DO NOT mention the topic itself in your spoken line.",
                transcriptContext = transcript.joinToString("\n") { "${it.speaker}: ${it.text}" },
                questionCountInPart = 0
            )
            processExamStep(request) { response ->
                if (response.examinerLine.isNotBlank()) transcript.add(
                    TranscriptEntry(
                        "Examiner",
                        response.examinerLine
                    )
                )
                updateState("moveToPart2_success") {
                    it.copy(
                        isLoading = false,
                        currentPart = ExamPart.PART_2_PREP,
                        part2CueCard = response.cueCard,
                        examinerMessage = response.examinerLine
                    )
                }
                playAudioQueue(listOfNotNull(response.inputIds)) { startPart2PrepTimer() }
            }
        }
    }

    private fun startPart2PrepTimer() {
        part2PrepTimerJob = viewModelScope.launch {
            for (i in PART_2_PREP_DURATION downTo 1) {
                updateState("part2PrepTimer") { it.copy(timerValue = i) }
                delay(1000)
            }
            updateState("startPart2PrepTimer_finished") {
                it.copy(
                    currentPart = ExamPart.PART_2_SPEAKING,
                    examinerMessage = "Your preparation time is over. Please start speaking now. You have up to 2 minutes.",
                    timerValue = 0
                )
            }
            startPart2SpeakingTimer()
            startUserSpeechRecognition()
        }
    }

    private fun startPart2SpeakingTimer() {
        part2SpeakingTimerJob = viewModelScope.launch {
            for (i in PART_2_SPEAKING_DURATION downTo 1) {
                updateState("part2SpeakingTimer") { it.copy(timerValue = i) }
                delay(1000)
            }
            if (_uiState.value.currentPart == ExamPart.PART_2_SPEAKING) {
                Log.d(
                    "ExamViewModel",
                    "Part 2 speaking timer finished. Forcing transition to Part 3."
                )
                shouldForcePartTransition.set(true)
                stopCurrentAudio() // Stop any pending audio
                if (_uiState.value.isRecording) {
                    recorder?.stop() // This will trigger onRecordingStopped -> handleTranscriptionResult
                } else {
                    moveToPart3()
                }
            }
        }
    }

    private fun moveToPart3() {
        part2SpeakingTimerJob?.cancel()
        part2PrepTimerJob?.cancel()
        questionCountInPart = 0
        updateState("moveToPart3") {
            it.copy(
                currentPart = ExamPart.PART_3,
                examinerMessage = "Thank you.",
                isLoading = true, timerValue = 0, isRecording = false,
                isReadyForUserInput = false, partialTranscription = "", part2CueCard = null
            )
        }
        startPart3Timer()
        viewModelScope.launch {
            val request = ExamStepRequest(
                part = 3,
                userInput = "The user has just finished their Part 2 talk. Say 'Thank you' and then begin Part 3 by asking the first discussion question.",
                transcriptContext = transcript.joinToString("\n") { "${it.speaker}: ${it.text}" },
                questionCountInPart = 0
            )
            processExamStep(request) { response ->
                if (response.examinerLine.isNotBlank()) transcript.add(
                    TranscriptEntry(
                        "Examiner",
                        response.examinerLine
                    )
                )
                updateState("moveToPart3_success") {
                    it.copy(
                        isLoading = false,
                        examinerMessage = response.examinerLine
                    )
                }
                playAudioQueue(listOfNotNull(response.inputIds))
            }
        }
    }

    private fun startPart3Timer() {
        part3TimerJob = viewModelScope.launch {
            for (i in PART_3_DURATION downTo 1) {
                updateState("part3Timer") { it.copy(timerValue = i) }
                delay(1000)
            }
            if (_uiState.value.currentPart == ExamPart.PART_3 && !isExamFinishedByTimer.get()) {
                Log.d("ExamViewModel", "Part 3 timer finished. Stopping recording to finalize.")
                isExamFinishedByTimer.set(true)
                shouldForcePartTransition.set(true)
                stopCurrentAudio() // Stop any pending audio
                if (_uiState.value.isRecording) {
                    recorder?.stop()
                } else {
                    concludeExamAndAnalyze()
                }
            }
        }
    }

    private fun continueWithPart3Questions(userInput: String) {
        if (_uiState.value.currentPart >= ExamPart.FINISHED) return
        updateState("continueWithPart3Questions") {
            it.copy(
                isLoading = true,
                partialTranscription = ""
            )
        }
        if (_uiState.value.timerValue <= FINAL_ANSWER_WINDOW_S) {
            Log.d("ExamViewModel", "Final answer received in time window. Concluding exam.")
            isExamFinishedByTimer.set(true)
            concludeExamAndAnalyze()
            return
        }
        questionCountInPart++
        val request = ExamStepRequest(
            part = 3,
            userInput = userInput,
            transcriptContext = transcript.joinToString("\n") { "${it.speaker}: ${it.text}" },
            questionCountInPart = questionCountInPart
        )
        processExamStep(request) { response ->
            if (response.examinerLine.isNotBlank()) transcript.add(
                TranscriptEntry(
                    "Examiner",
                    response.examinerLine
                )
            )
            updateState("continueWithPart3Questions_success") {
                it.copy(
                    isLoading = false,
                    examinerMessage = response.examinerLine
                )
            }
            playAudioQueue(listOfNotNull(response.inputIds))
        }
    }

    private fun concludeExamAndAnalyze() {
        if (_uiState.value.currentPart >= ExamPart.FINISHED) return
        cancelAllTimers()
        val finalMessage =
            "Thank you, that's the end of the IELTS Speaking Test. You will receive your results in a few moments."
        transcript.add(TranscriptEntry("Examiner", finalMessage))
        updateState("concludeExamAndAnalyze") {
            it.copy(
                currentPart = ExamPart.FINISHED,
                examinerMessage = finalMessage,
                timerValue = 0,
                isRecording = false,
                isReadyForUserInput = false,
                isLoading = true
            )
        }
        analyzeExam()
    }

    private fun analyzeExam() {
        viewModelScope.launch {
            when (val result = chatRepository.analyzeFullExam(transcript)) {
                is RepositoryResult.Success -> {
                    updateState("analyzeExam_success") {
                        it.copy(
                            currentPart = ExamPart.ANALYSIS_COMPLETE,
                            isLoading = false,
                            finalResultId = result.data.resultId
                        )
                    }
                }

                is RepositoryResult.Error -> {
                    Log.e("ExamViewModel", "Analysis failed: ${result.message}")
                    updateState("analyzeExam_error") {
                        it.copy(
                            isLoading = false,
                            error = "Analysis failed. Please try again later."
                        )
                    }
                }
            }
        }
    }

    private fun processExamStep(
        request: ExamStepRequest,
        onSuccess: (response: ExamStepResponse) -> Unit
    ) {
        if (_uiState.value.currentPart >= ExamPart.FINISHED) return
        viewModelScope.launch {
            when (val result = chatRepository.getNextExamStep(request)) {
                is RepositoryResult.Success -> {
                    onSuccess(result.data)
                }

                is RepositoryResult.Error -> {
                    updateState("processExamStep_error") {
                        it.copy(
                            isLoading = false,
                            error = result.message
                        )
                    }
                }
            }
        }
    }

    fun startUserSpeechRecognition() {
        if (recorder?.isRecording == true || isPlayingAudio || _uiState.value.currentPart >= ExamPart.FINISHED) return
        audioDataBuffer.clear()
        updateState("startUserSpeechRecognition") {
            it.copy(
                isRecording = true,
                partialTranscription = "",
                isReadyForUserInput = true
            )
        }
        recorder?.start()
    }

    fun stopUserSpeechRecognition() {
        if (recorder?.isRecording != true) return
        if (_uiState.value.currentPart == ExamPart.PART_2_SPEAKING) {
            part2SpeakingTimerJob?.cancel()
        }
        recorder?.stop()
        updateState("stopUserSpeechRecognition") {
            it.copy(
                isRecording = false,
                isReadyForUserInput = false,
                partialTranscription = "Processing..."
            )
        }
    }


    private fun cancelAllTimers() {
        part1TimerJob?.cancel()
        part2PrepTimerJob?.cancel()
        part2SpeakingTimerJob?.cancel()
        part3TimerJob?.cancel()
    }

    private fun getAssetFile(assetName: String): File {
        val file = File(context.cacheDir, assetName)
        if (!file.exists()) {
            context.assets.open(assetName).use { it.copyTo(file.outputStream()) }
        }
        return file
    }


    private fun stopCurrentAudio() {
        if (isPlayingAudio) {
            Log.d("ExamViewModel", "Stopping current audio playback due to timer expiration")
            isPlayingAudio = false
            audioQueue.clear()
            AudioPlayer.release() // Stop any currently playing audio
        }
    }

    // 4. Modify handleTranscriptionResult to respect forced transitions:
    private fun handleTranscriptionResult(transcription: String) {
        if (isExamFinishedByTimer.get()) {
            concludeExamAndAnalyze()
            return
        }

        // Check if we should force a transition regardless of transcription
        if (shouldForcePartTransition.get()) {
            shouldForcePartTransition.set(false)
            when (_uiState.value.currentPart) {
                ExamPart.PART_1 -> {
                    Log.d("ExamViewModel", "Forced transition from Part 1 to Part 2")
                    moveToPart2()
                }

                ExamPart.PART_2_SPEAKING -> {
                    Log.d("ExamViewModel", "Forced transition from Part 2 to Part 3")
                    moveToPart3()
                }

                ExamPart.PART_3 -> {
                    Log.d("ExamViewModel", "Forced transition to exam conclusion")
                    concludeExamAndAnalyze()
                }

                else -> { /* Handle other cases if needed */
                }
            }
            return
        }

        // Normal flow continues here
        when (_uiState.value.currentPart) {
            ExamPart.PART_1 -> continueWithPart1Questions(transcription)
            ExamPart.PART_2_SPEAKING -> moveToPart3()
            ExamPart.PART_3 -> continueWithPart3Questions(transcription)
            else -> { /* Do nothing */
            }
        }
    }

    // 5. Also modify playAudioQueue to check for forced transitions:
    private fun playAudioQueue(ids: List<List<Int>>, onComplete: (() -> Unit)? = null) {
        if (_uiState.value.currentPart >= ExamPart.FINISHED || ids.isEmpty() || ids.firstOrNull()
                ?.isEmpty() == true
        ) {
            if (onComplete != null) {
                onComplete()
            } else if (_uiState.value.currentPart < ExamPart.FINISHED) {
                startUserSpeechRecognition()
            }
            return
        }

        // Don't start audio if a forced transition is pending
        if (shouldForcePartTransition.get()) {
            if (onComplete != null) {
                onComplete()
            }
            return
        }

        isPlayingAudio = true
        updateState("playAudioQueue_start") { it.copy(isReadyForUserInput = false) }
        audioQueue.clear()
        audioQueue.addAll(ids)
        playNextAudioInQueue(onComplete)
    }

    private fun playNextAudioInQueue(onComplete: (() -> Unit)? = null) {
        // Check for forced transition before playing next audio
        if (shouldForcePartTransition.get() || audioQueue.isEmpty()) {
            isPlayingAudio = false
            if (onComplete != null) {
                onComplete()
            } else if (_uiState.value.currentPart < ExamPart.FINISHED && !shouldForcePartTransition.get()) {
                startUserSpeechRecognition()
            }
            return
        }

        viewModelScope.launch {
            val audioBytes = AudioPlayer.createAudioAndConvertToWav(
                audioQueue.removeAt(0).map { it.toLong() },
                context
            )
            AudioPlayer.playAudio(context, audioBytes) {
                // Check again after audio finishes in case timer expired during playback
                if (shouldForcePartTransition.get()) {
                    isPlayingAudio = false
                    if (onComplete != null) {
                        onComplete()
                    }
                } else {
                    playNextAudioInQueue(onComplete)
                }
            }
        }
    }

    fun stopExam() {
        if (uiState.value.currentPart >= ExamPart.FINISHED) {
            return // Already finished or stopped
        }
        Log.w("ExamViewModel", "Stopping exam forcefully due to interruption.")

        // 1. Cancel all active timers
        cancelAllTimers()

        // 2. Stop recorder and audio playback
        recorder?.stop()
        stopCurrentAudio() // This helper already handles AudioPlayer

        // 3. Update the UI to an interrupted state
        updateState("stopExam") {
            it.copy(
                currentPart = ExamPart.FINISHED, // Go to the final screen
                error = "The exam was interrupted.",
                isRecording = false,
                isLoading = false,
                isReadyForUserInput = false
            )
        }
    }

    override fun onCleared() {
        super.onCleared()
        Log.d("ExamViewModel", "onCleared: Releasing all resources.")
        stopExam()
        whisperEngine?.deinitialize()
    }
}

package com.typosbro.multilevel.ui.viewmodels

import android.content.Context
import android.util.Log
import androidx.annotation.RawRes
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.typosbro.multilevel.R
import com.typosbro.multilevel.data.remote.models.ExamContentIds
import com.typosbro.multilevel.data.remote.models.MultilevelAnalyzeRequest
import com.typosbro.multilevel.data.remote.models.MultilevelExamResponse
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import com.typosbro.multilevel.data.remote.models.TranscriptEntry
import com.typosbro.multilevel.data.repositories.MultilevelExamRepository
import com.typosbro.multilevel.features.whisper.Recorder
import com.typosbro.multilevel.features.whisper.engine.WhisperEngineNative
import com.typosbro.multilevel.utils.AudioPlayer
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import java.io.File
import javax.inject.Inject
import kotlin.coroutines.Continuation
import kotlin.coroutines.resume

// Enum to define the practice parts for type safety
enum class PracticePart {
    FULL, P1_1, P1_2, P2, P3
}

enum class MultilevelExamStage {
    NOT_STARTED, LOADING, INTRO, PART1_1_QUESTION, PART1_2_INTRO, PART1_2_COMPARE,
    PART1_2_FOLLOWUP, PART2_INTRO, PART2_PREP, PART2_SPEAKING, PART3_INTRO,
    PART3_PREP, PART3_SPEAKING, ANALYZING, FINISHED_ERROR
}


object MULTILEVEL_TIMEOUTS {
    const val PART1_1_PREP = 5
    const val PART1_1_ANSWER = 30
    const val PART1_2_PREP_FIRST = 10
    const val PART1_2_PREP_FOLLOWUP = 5
    const val PART1_2_ANSWER_FIRST = 45
    const val PART1_2_ANSWER_FOLLOWUP = 30
    const val PART2_PREP = 60
    const val PART2_SPEAKING = 120
    const val PART3_PREP = 60
    const val PART3_SPEAKING = 120
}

data class MultilevelUiState(
    val stage: MultilevelExamStage = MultilevelExamStage.NOT_STARTED,
    val examContent: MultilevelExamResponse? = null,
    val currentQuestionText: String? = null,
    val part1_1_QuestionIndex: Int = 0,
    val part1_2_QuestionIndex: Int = 0,
    val timerValue: Int = 0,
    val isRecording: Boolean = false,
    val transcript: List<TranscriptEntry> = emptyList(),
    val error: String? = null,
    val finalResultId: String? = null
)

@HiltViewModel
class MultilevelExamViewModel @Inject constructor(
    @ApplicationContext private val context: Context,
    private val repository: MultilevelExamRepository,
    savedStateHandle: SavedStateHandle // Inject SavedStateHandle
) : ViewModel(), Recorder.RecorderListener {

    private val _uiState = MutableStateFlow(MultilevelUiState())
    val uiState = _uiState.asStateFlow()

    private val practicePart: PracticePart =
        savedStateHandle.get<String>("practicePart")?.let {
            try {
                PracticePart.valueOf(it)
            } catch (e: IllegalArgumentException) {
                Log.e("ExamVM", "Invalid practice part argument: $it. Defaulting to FULL.")
                PracticePart.FULL
            }
        } ?: PracticePart.FULL

    private var whisperEngine: WhisperEngineNative? = null
    private val recorder: Recorder = Recorder(context, this)
    private var timerJob: Job? = null
    private val audioDataBuffer = mutableListOf<FloatArray>()
    private var transcriptionContinuation: Continuation<String>? = null

    init {
        viewModelScope.launch(Dispatchers.IO) {
            whisperEngine = WhisperEngineNative(context).also {
                val modelFile = getAssetFile("whisper-tiny.en.tflite")
                it.initialize(modelFile.absolutePath, "", false)
            }
        }
    }

    fun startExam() {
        if (uiState.value.stage != MultilevelExamStage.NOT_STARTED) return
        _uiState.update { it.copy(stage = MultilevelExamStage.LOADING) }

        viewModelScope.launch {
            when (val result = repository.getNewExam()) {
                is RepositoryResult.Success -> {
                    _uiState.update { it.copy(examContent = result.data) }
                    // Jump to the correct starting point based on the practice part
                    when (practicePart) {
                        PracticePart.FULL, PracticePart.P1_1 -> {
                            _uiState.update { it.copy(stage = MultilevelExamStage.INTRO) }
                            playInstructionAndWait(R.raw.multilevel_part1_intro)
                            playStartSpeakingSound()
                            startPart1_1()
                        }

                        PracticePart.P1_2 -> {
                            _uiState.update { it.copy(stage = MultilevelExamStage.PART1_2_INTRO) }
                            playInstructionAndWait(R.raw.multilevel_part1_2_intro)
                            processPart1_2_Question()
                        }

                        PracticePart.P2 -> {
                            _uiState.update { it.copy(stage = MultilevelExamStage.PART2_INTRO) }
                            playInstructionAndWait(R.raw.multilevel_part2_intro)
                            startPart2_Prep()
                        }

                        PracticePart.P3 -> {
                            _uiState.update { it.copy(stage = MultilevelExamStage.PART3_INTRO) }
                            playInstructionAndWait(R.raw.multilevel_part3_intro)
                            startPart3_Prep()
                        }
                    }
                }

                is RepositoryResult.Error -> {
                    _uiState.update {
                        it.copy(
                            stage = MultilevelExamStage.FINISHED_ERROR,
                            error = result.message
                        )
                    }
                }
            }
        }
    }

    private fun startPart1_1() {
        viewModelScope.launch {
            val content = _uiState.value.examContent?.part1_1 ?: return@launch
            val index = _uiState.value.part1_1_QuestionIndex
            if (index >= content.size) {
                // If this part is done, either move to the next or finish.
                if (practicePart == PracticePart.FULL) {
                    startPart1_2()
                } else {
                    concludeAndAnalyze()
                }
                return@launch
            }

            val question = content[index]
            _uiState.update {
                it.copy(
                    stage = MultilevelExamStage.PART1_1_QUESTION,
                    currentQuestionText = question.questionText
                )
            }
            addTranscript("Examiner", question.questionText)
            AudioPlayer.playFromUrlAndWait(context, question.audioUrl)

            startAnswerTimer(
                prepTime = MULTILEVEL_TIMEOUTS.PART1_1_PREP,
                answerTime = MULTILEVEL_TIMEOUTS.PART1_1_ANSWER
            )

            _uiState.update { it.copy(part1_1_QuestionIndex = index + 1) }
            startPart1_1() // Move to the next question
        }
    }

    private fun startPart1_2() {
        viewModelScope.launch {
            // This function is now only called when chaining from Part 1.1 in a FULL exam.
            _uiState.update { it.copy(stage = MultilevelExamStage.PART1_2_INTRO) }
            playInstructionAndWait(R.raw.multilevel_part1_2_intro)
            processPart1_2_Question()
        }
    }

    private fun processPart1_2_Question() {
        viewModelScope.launch {
            val set = _uiState.value.examContent?.part1_2 ?: return@launch
            val index = _uiState.value.part1_2_QuestionIndex
            if (index >= set.questions.size) {
                if (practicePart == PracticePart.FULL) {
                    startPart2()
                } else {
                    concludeAndAnalyze()
                }
                return@launch
            }

            val question = set.questions[index]
            val currentStage =
                if (index == 0) MultilevelExamStage.PART1_2_COMPARE else MultilevelExamStage.PART1_2_FOLLOWUP
            val prepTime =
                if (index == 0) MULTILEVEL_TIMEOUTS.PART1_2_PREP_FIRST else MULTILEVEL_TIMEOUTS.PART1_2_PREP_FOLLOWUP
            val answerTime =
                if (index == 0) MULTILEVEL_TIMEOUTS.PART1_2_ANSWER_FIRST else MULTILEVEL_TIMEOUTS.PART1_2_ANSWER_FOLLOWUP

            _uiState.update { it.copy(stage = currentStage, currentQuestionText = question.text) }
            addTranscript("Examiner", question.text)
            AudioPlayer.playFromUrlAndWait(context, question.audioUrl)

            startAnswerTimer(prepTime = prepTime, answerTime = answerTime)

            _uiState.update { it.copy(part1_2_QuestionIndex = index + 1) }
            processPart1_2_Question()
        }
    }

    private fun startPart2() {
        viewModelScope.launch {
            // This function is now only called when chaining from Part 1.2 in a FULL exam.
            _uiState.update { it.copy(stage = MultilevelExamStage.PART2_INTRO) }
            playInstructionAndWait(R.raw.multilevel_part2_intro)
            startPart2_Prep()
        }
    }

    private suspend fun startPart2_Prep() {
        val set = _uiState.value.examContent?.part2 ?: return
        val fullQuestionText = set.questions.joinToString("\n") { it.text }
        _uiState.update {
            it.copy(
                stage = MultilevelExamStage.PART2_PREP,
                currentQuestionText = fullQuestionText
            )
        }
        addTranscript("Examiner", fullQuestionText)
        val combinedAudioUrl = set.questions.firstOrNull()?.audioUrl ?: ""
        AudioPlayer.playFromUrlAndWait(context, combinedAudioUrl)
        startTimer(duration = MULTILEVEL_TIMEOUTS.PART2_PREP)
        startPart2_Speaking()
    }

    private suspend fun startPart2_Speaking() {
        _uiState.update { it.copy(stage = MultilevelExamStage.PART2_SPEAKING) }
        playStartSpeakingSound()
        recorder.start()
        _uiState.update { it.copy(isRecording = true) }
        startTimer(duration = MULTILEVEL_TIMEOUTS.PART2_SPEAKING)

        val transcribedText = stopRecordingAndTranscribe()
        if (transcribedText.isNotBlank()) {
            addTranscript("User", transcribedText)
        }

        if (practicePart == PracticePart.FULL) {
            startPart3()
        } else {
            concludeAndAnalyze()
        }
    }

    private fun startPart3() {
        viewModelScope.launch {
            // This function is now only called when chaining from Part 2 in a FULL exam.
            _uiState.update { it.copy(stage = MultilevelExamStage.PART3_INTRO) }
            playInstructionAndWait(R.raw.multilevel_part3_intro)
            startPart3_Prep()
        }
    }

    private suspend fun startPart3_Prep() {
        _uiState.update { it.copy(stage = MultilevelExamStage.PART3_PREP) }
        startTimer(duration = MULTILEVEL_TIMEOUTS.PART3_PREP)
        startPart3_Speaking()
    }

    private suspend fun startPart3_Speaking() {
        _uiState.update { it.copy(stage = MultilevelExamStage.PART3_SPEAKING) }
        playStartSpeakingSound()
        recorder.start()
        _uiState.update { it.copy(isRecording = true) }
        startTimer(duration = MULTILEVEL_TIMEOUTS.PART3_SPEAKING)

        val transcribedText = stopRecordingAndTranscribe()
        if (transcribedText.isNotBlank()) {
            addTranscript("User", transcribedText)
        }

        concludeAndAnalyze()
    }

    private fun concludeAndAnalyze() {
        _uiState.update { it.copy(stage = MultilevelExamStage.ANALYZING) }
        viewModelScope.launch {
            val examContent = uiState.value.examContent ?: return@launch
            val contentIds = ExamContentIds(
                part1_1 = examContent.part1_1.map { it.id },
                part1_2 = examContent.part1_2.id,
                part2 = examContent.part2.id,
                part3 = examContent.part3.id
            )
            // Add the specific practice part to the request, or null for a full exam
            val partString = if (practicePart == PracticePart.FULL) null else practicePart.name
            val request = MultilevelAnalyzeRequest(uiState.value.transcript, contentIds, partString)

            when (val result = repository.analyzeExam(request)) {
                is RepositoryResult.Success -> {
                    _uiState.update { it.copy(finalResultId = result.data.resultId) }
                }

                is RepositoryResult.Error -> {
                    _uiState.update {
                        it.copy(
                            stage = MultilevelExamStage.FINISHED_ERROR,
                            error = result.message
                        )
                    }
                }
            }
        }
    }

    private suspend fun startAnswerTimer(prepTime: Int, answerTime: Int) {
        timerJob?.cancel()
        val newTimerJob = viewModelScope.launch {
            _uiState.update { it.copy(isRecording = false) }
            for (i in prepTime downTo 1) {
                _uiState.update { it.copy(timerValue = i) }
                delay(1000)
            }
            _uiState.update { it.copy(timerValue = 0) }

            playStartSpeakingSound()
            recorder.start()
            _uiState.update { it.copy(isRecording = true) }
            for (i in answerTime downTo 1) {
                _uiState.update { it.copy(timerValue = i) }
                delay(1000)
            }
            _uiState.update { it.copy(timerValue = 0) }

            val transcribedText = stopRecordingAndTranscribe()
            if (transcribedText.isNotBlank()) {
                addTranscript("User", transcribedText)
            }
        }
        timerJob = newTimerJob
        newTimerJob.join()
    }

    private suspend fun stopRecordingAndTranscribe(): String {
        return suspendCancellableCoroutine { continuation ->
            transcriptionContinuation = continuation
            recorder.stop()
        }
    }

    override fun onRecordingStopped() {
        viewModelScope.launch {
            try {
                _uiState.update { it.copy(isRecording = false) }
                // Play a sound to indicate recording has stopped, as requested.
                playStartSpeakingSound()
                val transcribedText = transcribeBufferedAudio()
                val cleanText =
                    if (transcribedText.isBlank() || transcribedText.all { !it.isLetter() }) "" else transcribedText
                Log.d("ExamVM", "Recording stopped. Transcribed: '$cleanText'")
                transcriptionContinuation?.resume(cleanText)
            } catch (e: Exception) {
                Log.e("ExamVM", "Error in onRecordingStopped", e)
                transcriptionContinuation?.resume("")
            } finally {
                transcriptionContinuation = null
            }
        }
    }

    private suspend fun startTimer(duration: Int) {
        timerJob?.cancel()
        val newTimerJob = viewModelScope.launch {
            for (i in duration downTo 1) {
                _uiState.update { it.copy(timerValue = i) }
                delay(1000)
            }
            _uiState.update { it.copy(timerValue = 0) }
        }
        timerJob = newTimerJob
        newTimerJob.join()
    }

    override fun onDataReceived(samples: FloatArray) {
        synchronized(audioDataBuffer) {
            audioDataBuffer.add(samples)
        }
    }

    private suspend fun transcribeBufferedAudio(): String {
        val allSamples: FloatArray
        synchronized(audioDataBuffer) {
            if (audioDataBuffer.isEmpty()) return ""
            val totalSamples = audioDataBuffer.sumOf { it.size }
            if (totalSamples < 1600) {
                audioDataBuffer.clear()
                return ""
            }

            allSamples = FloatArray(totalSamples)
            var destinationPos = 0
            audioDataBuffer.forEach { chunk ->
                System.arraycopy(chunk, 0, allSamples, destinationPos, chunk.size)
                destinationPos += chunk.size
            }
            audioDataBuffer.clear()

            val maxAmplitude = allSamples.maxOrNull() ?: 0f
            if (maxAmplitude < 0.001f) return ""
        }

        return withContext(Dispatchers.Default) {
            try {
                val rawResult = whisperEngine?.transcribeBuffer(allSamples) ?: ""
                sanitizeUtf8String(rawResult)
            } catch (t: Throwable) {
                Log.e("ExamViewModel", "Whisper transcription failed", t)
                ""
            }
        }
    }

    private fun sanitizeUtf8String(input: String): String {
        return try {
            input.replace(Regex("[\\p{Cntrl}&&[^\r\n\t]]"), "")
                .replace(Regex("[\uFFFD\u0000-\u001F\u007F-\u009F]"), "")
                .trim()
        } catch (e: Exception) {
            Log.w("ExamViewModel", "Failed to sanitize UTF-8 string", e)
            ""
        }
    }

    private suspend fun playInstructionAndWait(@RawRes resId: Int) {
        try {
            // This function should ONLY play the instruction and wait.
            // The "start speaking" sound is handled by the functions that actually start a speaking timer.
            AudioPlayer.playFromRawAndWait(context, resId)
        } catch (e: Exception) {
            Log.e("ExamVM", "Instruction audio failed to play", e)
            _uiState.update { it.copy(error = "Audio playback failed. Please try again.") }
        }
    }

    private suspend fun playStartSpeakingSound() {
        try {
            AudioPlayer.playFromRawAndWait(context, R.raw.start_speaking_sound)
        } catch (e: Exception) {
            Log.e("ExamVM", "Start speaking sound failed", e)
        }
    }

    private fun addTranscript(speaker: String, text: String) {
        val newEntry = TranscriptEntry(speaker, text)
        _uiState.update { it.copy(transcript = it.transcript + newEntry) }
    }


    private fun getAssetFile(assetName: String): File {
        val file = File(context.cacheDir, assetName)
        if (!file.exists()) {
            context.assets.open(assetName).use { it.copyTo(file.outputStream()) }
        }
        return file
    }

    fun stopExam() {
        val currentStage = uiState.value.stage
        if (currentStage == MultilevelExamStage.NOT_STARTED || currentStage == MultilevelExamStage.LOADING || currentStage == MultilevelExamStage.FINISHED_ERROR || currentStage == MultilevelExamStage.ANALYZING) {
            return
        }
        Log.w("ExamVM", "Stopping exam forcefully due to interruption.")
        timerJob?.cancel()
        recorder.stop()
        AudioPlayer.release()
        transcriptionContinuation?.resume("")
        transcriptionContinuation = null
        _uiState.update {
            it.copy(
                stage = MultilevelExamStage.FINISHED_ERROR,
                error = "The exam was interrupted.",
                isRecording = false,
                timerValue = 0
            )
        }
    }

    override fun onCleared() {
        super.onCleared()
        stopExam()
        whisperEngine?.deinitialize()
    }
}

package com.typosbro.multilevel.ui.viewmodels

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.typosbro.multilevel.data.remote.models.MultilevelExamResultResponse
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import com.typosbro.multilevel.data.repositories.MultilevelExamRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class MultilevelResultUiState(
    val isLoading: Boolean = true,
    val error: String? = null,
    val result: MultilevelExamResultResponse? = null
)

@HiltViewModel
class MultilevelResultViewModel @Inject constructor(
    private val repository: MultilevelExamRepository,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _uiState = MutableStateFlow(MultilevelResultUiState())
    val uiState = _uiState.asStateFlow()

    private val resultId: String = checkNotNull(savedStateHandle["resultId"])

    init {
        fetchResultDetails()
    }

    private fun fetchResultDetails() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }

            // This would call a new function in your repository
            when (val result = repository.getExamResultDetails(resultId)) {
                is RepositoryResult.Success -> {
                    _uiState.update { it.copy(isLoading = false, result = result.data) }
                }

                is RepositoryResult.Error -> {
                    _uiState.update { it.copy(isLoading = false, error = result.message) }
                }
            }
        }
    }
}

package com.typosbro.multilevel.ui.viewmodels

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.typosbro.multilevel.data.remote.models.GenericSuccessResponse
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import com.typosbro.multilevel.data.remote.models.UserProfileResponse
import com.typosbro.multilevel.data.repositories.AuthRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.util.Locale
import javax.inject.Inject

data class UserProfileViewData(
    val id: String,
    val displayName: String,
    val primaryIdentifier: String,
    val registeredDate: String,
    val authProvider: String,
)

data class ProfileUiState(
    val isLoading: Boolean = false,
    val error: String? = null,
    val userProfile: UserProfileViewData? = null,
    val deleteState: UiState<GenericSuccessResponse> = UiState.Idle
)

@HiltViewModel
class ProfileViewModel @Inject constructor(
    private val authRepository: AuthRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(ProfileUiState())
    val uiState = _uiState.asStateFlow()

    init {
        fetchUserProfile()
    }

    fun fetchUserProfile() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }
            when (val result = authRepository.getUserProfile()) {
                is RepositoryResult.Success -> {
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            userProfile = result.data.toViewData()
                        )
                    }
                }

                is RepositoryResult.Error -> {
                    _uiState.update {
                        it.copy(isLoading = false, error = result.message)
                    }
                }
            }
        }
    }

    fun deleteAccount() {
        viewModelScope.launch {
            _uiState.update { it.copy(deleteState = UiState.Loading) }
            val result = authRepository.deleteUserProfile()
            when (result) {
                is RepositoryResult.Success -> {
                    _uiState.update { it.copy(deleteState = UiState.Success(result.data)) }
                }

                is RepositoryResult.Error -> {
                    _uiState.update { it.copy(deleteState = UiState.Error(result.message)) }
                }
            }
        }
    }

    fun resetDeleteState() {
        _uiState.update { it.copy(deleteState = UiState.Idle) }
    }
}

// Helper extension function to format the data for the UI
private fun UserProfileResponse.toViewData(): UserProfileViewData {
    val parser = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.getDefault())
    val formatter = SimpleDateFormat("dd MMMM yyyy", Locale.getDefault())
    val date = try {
        parser.parse(this.createdAt)
    } catch (e: Exception) {
        null
    }

    // --- THIS IS THE CORRECTED LOGIC ---
    // We use the safe call operator (?.) to prevent a crash if authProvider is null.
    // The Elvis operator (?:) provides a default value ("unknown") in that case.
    val displayName = when (this.authProvider?.lowercase()) {
        "google" -> this.firstName ?: this.email ?: "Google User"
        "telegram" -> this.firstName ?: this.username?.let { "@$it" } ?: "Telegram User"
        else -> "User" // Default for unknown or null providers
    }

    val primaryIdentifier = this.email ?: this.telegramId?.toString() ?: "No identifier"

    val providerName = this.authProvider?.replaceFirstChar {
        if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString()
    } ?: "Unknown"
    // --- END OF CORRECTION ---

    return UserProfileViewData(
        id = this.id,
        displayName = displayName,
        primaryIdentifier = primaryIdentifier,
        registeredDate = date?.let { formatter.format(it) } ?: "N/A",
        authProvider = providerName
    )
}

package com.typosbro.multilevel.ui.viewmodels

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import com.typosbro.multilevel.data.repositories.ChatRepository
import com.typosbro.multilevel.data.repositories.MultilevelExamRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.async
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

// An enum to identify the exam type in a type-safe way
enum class ExamType {
    IELTS,
    MULTILEVEL
}

// A unified data class to represent a summary for any exam type in the UI
// UPDATED: Added practicePart to help with filtering
data class GenericExamResultSummary(
    val id: String,
    val examDate: Long,
    val score: Double,
    val scoreLabel: String, // e.g., "Overall Band" or "Total Score"
    val type: ExamType,
    val practicePart: String = "FULL" // Default for IELTS or full exams
)

data class ProgressUiState(
    val isLoading: Boolean = true,
    val error: String? = null,
    val selectedTab: ExamType = ExamType.MULTILEVEL,
    val ieltsHistory: List<GenericExamResultSummary> = emptyList(),
    // UPDATED: multilevelHistory is now a map to group results by part
    val multilevelHistory: Map<String, List<GenericExamResultSummary>> = emptyMap(),
    // UPDATED: State to hold the selected sub-category for Multilevel
    val selectedMultilevelPart: String = "FULL"
)

@HiltViewModel
class ProgressViewModel @Inject constructor(
    private val ieltsRepository: ChatRepository, // Renamed for clarity
    private val multilevelExamRepository: MultilevelExamRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(ProgressUiState())
    val uiState = _uiState.asStateFlow()

    // A helper map to define max scores for the chart
    private val multilevelMaxScores = mapOf(
        "FULL" to 72.0, "P1_1" to 12.0, "P1_2" to 12.0, "P2" to 24.0, "P3" to 24.0
    )

    init {
        loadAllHistories()
    }

    fun selectTab(type: ExamType) {
        _uiState.update { it.copy(selectedTab = type) }
    }

    // NEW function to handle sub-category selection
    fun selectMultilevelPart(part: String) {
        _uiState.update { it.copy(selectedMultilevelPart = part) }
    }


    private fun loadAllHistories() {
        _uiState.update { it.copy(isLoading = true) }
        viewModelScope.launch {
            // Fetch both histories in parallel for better performance
            // CORRECTED variable names for clarity
            val multilevelDeferred = async { multilevelExamRepository.getExamHistory() }
            val ieltsDeferred = async { ieltsRepository.getExamHistorySummary() }

            val multilevelResult = multilevelDeferred.await()
            val ieltsResult = ieltsDeferred.await()

            var ieltsHistory: List<GenericExamResultSummary> = emptyList()
            var multilevelHistoryMap: Map<String, List<GenericExamResultSummary>> = emptyMap()
            var error: String? = null

            // Process IELTS results
            when (ieltsResult) {
                is RepositoryResult.Success -> {
                    ieltsHistory = ieltsResult.data.history.map { summary ->
                        GenericExamResultSummary(
                            id = summary.id,
                            examDate = summary.examDate,
                            score = summary.overallBand,
                            scoreLabel = "Overall Band: ${summary.overallBand}",
                            type = ExamType.IELTS
                        )
                    }.sortedByDescending { it.examDate }
                }

                is RepositoryResult.Error -> error = ieltsResult.message
            }

            // Process Multilevel results
            when (multilevelResult) {
                is RepositoryResult.Success -> {
                    multilevelHistoryMap = multilevelResult.data.history.map { summary ->
                        val maxScore =
                            multilevelMaxScores[summary.practicePart] ?: summary.totalScore
                        GenericExamResultSummary(
                            id = summary.id,
                            examDate = summary.examDate,
                            score = summary.totalScore.toDouble(),
                            scoreLabel = "Score: ${summary.totalScore} / ${maxScore.toInt()}",
                            type = ExamType.MULTILEVEL,
                            practicePart = summary.practicePart
                        )
                    }.sortedByDescending { it.examDate }
                        .groupBy { it.practicePart } // The key change: grouping by part
                }

                is RepositoryResult.Error -> error =
                    error ?: multilevelResult.message // Keep first error
            }

            _uiState.update {
                it.copy(
                    isLoading = false,
                    ieltsHistory = ieltsHistory,
                    multilevelHistory = multilevelHistoryMap,
                    error = error,
                    // Ensure a valid part is selected, default to FULL if available
                    selectedMultilevelPart = if (multilevelHistoryMap.containsKey("FULL")) "FULL" else multilevelHistoryMap.keys.firstOrNull()
                        ?: "FULL"
                )
            }
        }
    }
}

package com.typosbro.multilevel.ui.viewmodels

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.typosbro.multilevel.data.preferences.LanguageRepository
import com.typosbro.multilevel.data.preferences.ThemeRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class SettingsViewModel @Inject constructor(
    private val themeRepository: ThemeRepository,
    private val languageRepository: LanguageRepository // Inject the new repository
) : ViewModel() {

    // Expose the theme preference as a StateFlow
    val isDarkTheme = themeRepository.isDarkTheme
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = false
        )

    // Expose the language preference as a StateFlow
    val currentLanguageCode: StateFlow<String?> = languageRepository.languageCode
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = null // The initial value is null, representing "not loaded yet"
        )

    /**
     * Called by the UI when the theme switch is toggled.
     */
    fun onThemeChanged(isDark: Boolean) {
        viewModelScope.launch {
            themeRepository.setTheme(isDark)
        }
    }

    /**
     * Called by the UI when a new language is selected.
     */
    fun onLanguageChanged(languageCode: String) {
        viewModelScope.launch {
            languageRepository.setLanguage(languageCode)
        }
    }
}

package com.typosbro.multilevel.ui.viewmodels

/**
 * A generic sealed interface to represent UI states for asynchronous operations.
 * It provides clear states for Idle, Loading, Success with data, and Error with a message.
 */
sealed interface UiState<out T> {
    object Idle : UiState<Nothing>
    object Loading : UiState<Nothing>
    data class Success<T>(val data: T) : UiState<T>
    data class Error(val message: String) : UiState<Nothing>
}

package com.typosbro.multilevel.ui.viewmodels

import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.typosbro.multilevel.data.local.WordDao
import com.typosbro.multilevel.data.local.WordEntity
import com.typosbro.multilevel.data.remote.models.ApiWord
import com.typosbro.multilevel.data.remote.models.RepositoryResult
import com.typosbro.multilevel.data.repositories.WordBankRepository
import com.typosbro.multilevel.features.srs.ReviewQuality
import com.typosbro.multilevel.features.srs.SM2
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class DeckInfo(
    val name: String,
    val level: String,
    val topic: String?,
    val dueCount: Int,
    val newCount: Int,
    val totalCount: Int,
    val subDecks: List<DeckInfo> = emptyList()
)

data class WordBankUiState(
    // Global stats
    val totalDue: Int = 0,
    val totalNew: Int = 0,
    val totalWords: Int = 0,

    // For hierarchical deck screen
    val deckHierarchy: List<DeckInfo> = emptyList(),

    // For "Explore" flow
    val exploreLevels: List<String> = emptyList(),
    val exploreTopics: List<String> = emptyList(),
    val exploreLevelsAddedStatus: Map<String, Boolean> = emptyMap(),
    val exploreTopicAddedStatus: Map<String, Boolean> = emptyMap(),
    val loadingItems: Set<String> = emptySet(),

    // Review Session State
    val reviewWords: List<WordEntity> = emptyList(),
    val currentReviewIndex: Int = 0,
    val isSessionActive: Boolean = false,
    val isSessionFinished: Boolean = false,
    val lapsedWords: List<WordEntity> = emptyList(), // Queue for failed cards to show again

    // Common State
    val isLoading: Boolean = false,
    val error: String? = null,
) {
    val currentWord: WordEntity?
        get() = reviewWords.getOrNull(currentReviewIndex)
}

@HiltViewModel
class WordBankViewModel @Inject constructor(
    private val wordDao: WordDao,
    private val wordBankRepository: WordBankRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _uiState = MutableStateFlow(WordBankUiState())
    val uiState: StateFlow<WordBankUiState> = _uiState.asStateFlow()

    init {
        viewModelScope.launch {
            combine(
                wordDao.getDueWordsCount(System.currentTimeMillis()),
                wordDao.getNewWordsCount(),
                wordDao.getTotalWordsCount()
            ) { due, new, total ->
                _uiState.update { it.copy(totalDue = due, totalNew = new, totalWords = total) }
            }.collect()
        }
    }

    // --- Deck Hierarchy Logic ---
    fun loadDeckHierarchy() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val levelsResult = wordBankRepository.getLevels()
            if (levelsResult !is RepositoryResult.Success) {
                _uiState.update { it.copy(isLoading = false, error = "Could not load levels.") }
                return@launch
            }
            val levels = levelsResult.data
            val hierarchy = coroutineScope {
                levels.map { level ->
                    async {
                        val now = System.currentTimeMillis()
                        val topicsResult = wordBankRepository.getTopics(level)
                        val topics =
                            if (topicsResult is RepositoryResult.Success) topicsResult.data else emptyList()
                        val subDecks = topics.map { topic ->
                            DeckInfo(
                                name = topic, level = level, topic = topic,
                                dueCount = wordDao.countDueWordsInTopic(level, topic, now),
                                newCount = wordDao.countNewWordsInTopic(level, topic),
                                totalCount = wordDao.countTotalWordsInTopic(level, topic)
                            )
                        }
                        DeckInfo(
                            name = level, level = level, topic = null,
                            dueCount = subDecks.sumOf { it.dueCount },
                            newCount = subDecks.sumOf { it.newCount },
                            totalCount = subDecks.sumOf { it.totalCount },
                            subDecks = subDecks.filter { it.totalCount > 0 }.sortedBy { it.name }
                        )
                    }
                }.awaitAll()
            }
            _uiState.update {
                it.copy(
                    deckHierarchy = hierarchy.filter { it.totalCount > 0 }.sortedBy { it.name },
                    isLoading = false
                )
            }
        }
    }

    // --- Review Session Logic ---
    fun startReviewSession(level: String? = null, topic: String? = null) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, isSessionActive = true) }
            val dueList = wordDao.getDueWords(System.currentTimeMillis(), level, topic).first()
            _uiState.update {
                it.copy(
                    reviewWords = dueList.shuffled(),
                    lapsedWords = emptyList(), // Ensure lapse queue is empty at the start
                    currentReviewIndex = 0,
                    isSessionActive = dueList.isNotEmpty(),
                    isSessionFinished = false,
                    isLoading = false
                )
            }
        }
    }

    fun handleReview(word: WordEntity, quality: ReviewQuality) {
        viewModelScope.launch {
            if (quality == ReviewQuality.AGAIN) {
                // If the user fails, add the card to a temporary "lapse" queue to be shown again soon.
                _uiState.update {
                    it.copy(lapsedWords = it.lapsedWords + word)
                }
            } else {
                // If the user succeeds, update the card's SRS data and save it to the database.
                val updatedWord = SM2.calculate(word, quality)
                wordDao.update(updatedWord)
            }

            val nextIndex = _uiState.value.currentReviewIndex + 1

            if (nextIndex >= _uiState.value.reviewWords.size) {
                // The main review queue is finished. Check if there are any failed cards.
                if (_uiState.value.lapsedWords.isNotEmpty()) {
                    // If so, start a new round with the failed cards.
                    _uiState.update {
                        it.copy(
                            reviewWords = it.lapsedWords.shuffled(),
                            lapsedWords = emptyList(), // Clear the lapse queue for the next round
                            currentReviewIndex = 0
                        )
                    }
                } else {
                    // If there are no failed cards, the session is truly over.
                    _uiState.update { it.copy(isSessionFinished = true, isSessionActive = false) }
                }
            } else {
                // Otherwise, just move to the next card in the current queue.
                _uiState.update { it.copy(currentReviewIndex = nextIndex) }
            }
        }
    }

    // --- Word Discovery Logic ---
    fun fetchExploreLevels() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            val result = wordBankRepository.getLevels()
            if (result is RepositoryResult.Success) {
                val levels = result.data
                val statusMap = levels.associateWith { level ->
                    wordDao.countTotalWordsInLevel(level) > 0
                }
                _uiState.update {
                    it.copy(
                        exploreLevels = levels,
                        exploreLevelsAddedStatus = statusMap,
                        isLoading = false
                    )
                }
            } else if (result is RepositoryResult.Error) {
                _uiState.update { it.copy(error = result.message, isLoading = false) }
            }
        }
    }

    fun fetchExploreTopics(level: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, exploreTopics = emptyList()) }
            val result = wordBankRepository.getTopics(level)
            if (result is RepositoryResult.Success) {
                val topics = result.data
                val statusMap = topics.associateWith { topic ->
                    wordDao.countTotalWordsInTopic(level, topic) > 0
                }
                _uiState.update {
                    it.copy(
                        exploreTopics = topics,
                        exploreTopicAddedStatus = statusMap,
                        isLoading = false
                    )
                }
            } else if (result is RepositoryResult.Error) {
                _uiState.update { it.copy(error = result.message, isLoading = false) }
            }
        }
    }

    private fun wordsToEntities(apiWords: List<ApiWord>): List<WordEntity> {
        return apiWords.map { apiWord ->
            WordEntity(
                word = apiWord.word,
                translation = apiWord.translation,
                example1 = apiWord.example1,
                example1Translation = apiWord.example1Translation,
                example2 = apiWord.example2,
                example2Translation = apiWord.example2Translation,
                cefrLevel = apiWord.cefrLevel,
                topic = apiWord.topic,
                repetitions = 0,
                easinessFactor = 2.5f,
                interval = 0,
                nextReviewTimestamp = System.currentTimeMillis()
            )
        }
    }

    fun addWordsByTopic(level: String, topic: String) {
        viewModelScope.launch {
            val loadingKey = "${level}_$topic"
            _uiState.update { it.copy(loadingItems = it.loadingItems + loadingKey) }
            val result = wordBankRepository.getWords(level, topic)
            if (result is RepositoryResult.Success) {
                wordDao.insertAll(wordsToEntities(result.data))
                fetchExploreTopics(level)
                loadDeckHierarchy()
            }
            _uiState.update { it.copy(loadingItems = it.loadingItems - loadingKey) }
        }
    }

    fun removeWordsByTopic(level: String, topic: String) {
        viewModelScope.launch {
            val loadingKey = "${level}_$topic"
            _uiState.update { it.copy(loadingItems = it.loadingItems + loadingKey) }
            wordDao.deleteByTopic(level, topic)
            fetchExploreTopics(level)
            loadDeckHierarchy()
            _uiState.update { it.copy(loadingItems = it.loadingItems - loadingKey) }
        }
    }

    fun addWordsByLevel(level: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(loadingItems = it.loadingItems + level) }
            val result = wordBankRepository.getAllWordsForLevel(level)
            if (result is RepositoryResult.Success) {
                wordDao.insertAll(wordsToEntities(result.data))
                fetchExploreLevels()
                loadDeckHierarchy()
            }
            _uiState.update { it.copy(loadingItems = it.loadingItems - level) }
        }
    }

    fun removeWordsByLevel(level: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(loadingItems = it.loadingItems + level) }
            wordDao.deleteByLevel(level)
            fetchExploreLevels()
            loadDeckHierarchy()
            _uiState.update { it.copy(loadingItems = it.loadingItems - level) }
        }
    }
}

package com.typosbro.multilevel.utils

import android.content.Context
import android.content.pm.PackageManager

/**
 * Gets the version name of the app (e.g., "1.0.0") from the package manager.
 */
fun getAppVersion(context: Context): String {
    return try {
        val packageInfo = context.packageManager.getPackageInfo(context.packageName, 0)
        packageInfo.versionName
    } catch (e: PackageManager.NameNotFoundException) {
        "N/A" // Should not happen
    }.toString()
}

package com.typosbro.multilevel.utils

import ai.onnxruntime.OnnxTensor
import ai.onnxruntime.OrtEnvironment
import ai.onnxruntime.OrtSession
import android.content.Context
import android.media.AudioAttributes
import android.media.MediaPlayer
import android.net.Uri
import android.util.Log
import androidx.annotation.RawRes
import com.typosbro.multilevel.features.inference.OnnxRuntimeManager
import com.typosbro.multilevel.features.inference.StyleLoader
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

object AudioPlayer {

    private var currentMediaPlayer: MediaPlayer? = null
    private var tempAudioFile: File? = null

    // --- NEW ROBUST SUSPENDABLE PLAYBACK FUNCTIONS ---

    /**
     * Plays audio from a raw resource and suspends the coroutine until playback is complete or fails.
     * This version is robust against race conditions using a try/finally block for cleanup.
     */
    suspend fun playFromRawAndWait(context: Context, @RawRes rawResId: Int) {
        stopCurrentSound() // Stop any sound that might be playing.

        val player = MediaPlayer()
        currentMediaPlayer = player // Assign so it can be stopped externally if needed.

        try {
            suspendCancellableCoroutine<Unit> { continuation ->
                val uri = Uri.parse("android.resource://${context.packageName}/$rawResId")

                continuation.invokeOnCancellation {
                    Log.d(
                        "AudioPlayer",
                        "SUSPEND: Coroutine cancelled for raw $rawResId. The 'finally' block will handle cleanup."
                    )
                }

                try {
                    player.setAudioAttributes(
                        AudioAttributes.Builder()
                            .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                            .setUsage(AudioAttributes.USAGE_MEDIA).build()
                    )
                    player.setDataSource(context, uri)
                    player.setOnPreparedListener { it.start() }
                    player.setOnCompletionListener {
                        if (continuation.isActive) continuation.resume(Unit)
                    }
                    player.setOnErrorListener { _, what, extra ->
                        val error =
                            RuntimeException("MediaPlayer error for raw $rawResId: what=$what, extra=$extra")
                        if (continuation.isActive) continuation.resumeWithException(error)
                        true
                    }
                    player.prepareAsync()
                } catch (e: Exception) {
                    if (continuation.isActive) continuation.resumeWithException(e)
                }
            }
        } finally {
            // This is guaranteed to run once the coroutine is done, preventing race conditions.
            cleanupPlayerInstance(player, "playFromRawAndWait finally block")
        }
    }

    /**
     * Plays audio from a URL and suspends the coroutine until playback is complete or fails.
     * This version is robust against race conditions using a try/finally block for cleanup.
     */
    suspend fun playFromUrlAndWait(context: Context, url: String) {
        stopCurrentSound()

        val player = MediaPlayer()
        currentMediaPlayer = player

        try {
            suspendCancellableCoroutine<Unit> { continuation ->
                continuation.invokeOnCancellation {
                    Log.d(
                        "AudioPlayer",
                        "SUSPEND: Coroutine cancelled for URL $url. The 'finally' block will handle cleanup."
                    )
                }

                try {
                    player.setAudioAttributes(
                        AudioAttributes.Builder()
                            .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                            .setUsage(AudioAttributes.USAGE_MEDIA).build()
                    )
                    player.setDataSource(url)
                    player.setOnPreparedListener { it.start() }
                    player.setOnCompletionListener {
                        if (continuation.isActive) continuation.resume(Unit)
                    }
                    player.setOnErrorListener { _, what, extra ->
                        val error =
                            RuntimeException("MediaPlayer error for URL $url: what=$what, extra=$extra")
                        if (continuation.isActive) continuation.resumeWithException(error)
                        true
                    }
                    player.prepareAsync()
                } catch (e: Exception) {
                    if (continuation.isActive) continuation.resumeWithException(e)
                }
            }
        } finally {
            cleanupPlayerInstance(player, "playFromUrlAndWait finally block")
        }
    }

    // --- Original Functions (kept for compatibility) ---

    fun playFromUrl(context: Context, url: String, onCompletionCallback: () -> Unit) {
        Log.d("AudioPlayer", "Attempting to play from URL: $url")
        stopCurrentSound()
        val player = MediaPlayer()
        currentMediaPlayer = player
        try {
            player.setAudioAttributes(
                AudioAttributes.Builder()
                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                    .setUsage(AudioAttributes.USAGE_MEDIA).build()
            )
            player.setDataSource(url)
            player.setOnPreparedListener {
                it.start()
            }
            player.setOnCompletionListener {
                onCompletionCallback.invoke()
                cleanupPlayerInstance(it, "URL playback (non-suspend)")
            }
            player.setOnErrorListener { mp, what, extra ->
                Log.e("AudioPlayer", "MediaPlayer error for URL ($url): what=$what, extra=$extra")
                onCompletionCallback.invoke()
                cleanupPlayerInstance(mp, "URL error (non-suspend)")
                true
            }
            player.prepareAsync()
        } catch (e: Exception) {
            Log.e("AudioPlayer", "Exception setting up MediaPlayer for URL ($url)", e)
            onCompletionCallback.invoke()
            cleanupPlayerInstance(player, "URL setup exception (non-suspend)")
        }
    }

    fun playFromRaw(context: Context, @RawRes rawResId: Int, onCompletionCallback: () -> Unit) {
        Log.d("AudioPlayer", "Attempting to play from raw resource ID: $rawResId")
        stopCurrentSound()
        val player = MediaPlayer()
        currentMediaPlayer = player
        val uri = Uri.parse("android.resource://${context.packageName}/$rawResId")
        try {
            player.setAudioAttributes(
                AudioAttributes.Builder()
                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                    .setUsage(AudioAttributes.USAGE_MEDIA).build()
            )
            player.setDataSource(context, uri)
            player.setOnPreparedListener { it.start() }
            player.setOnCompletionListener {
                onCompletionCallback.invoke()
                cleanupPlayerInstance(it, "Raw playback (non-suspend)")
            }
            player.setOnErrorListener { mp, what, extra ->
                Log.e(
                    "AudioPlayer",
                    "MediaPlayer error for raw resource ($rawResId): what=$what, extra=$extra"
                )
                onCompletionCallback.invoke()
                cleanupPlayerInstance(mp, "Raw error (non-suspend)")
                true
            }
            player.prepareAsync()
        } catch (e: Exception) {
            Log.e("AudioPlayer", "Exception setting up MediaPlayer for raw resource ($rawResId)", e)
            onCompletionCallback.invoke()
            cleanupPlayerInstance(player, "Raw setup exception (non-suspend)")
        }
    }

    /**
     * The main function to play audio from a byte array. It writes the bytes to a temporary
     * file and then plays it using MediaPlayer.
     */
    fun playAudio(context: Context, audioBytes: ByteArray, onCompletion: (() -> Unit)? = null) {
        Log.d("AudioPlayer", "Attempting to play audio from byte array.")
        stopCurrentSound()

        val player = MediaPlayer()
        currentMediaPlayer = player

        try {
            tempAudioFile = File.createTempFile("audio_tts_", ".wav", context.cacheDir).apply {
                FileOutputStream(this).use { fos -> fos.write(audioBytes) }
                deleteOnExit()
            }
            player.setAudioAttributes(
                AudioAttributes.Builder()
                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                    .setUsage(AudioAttributes.USAGE_MEDIA).build()
            )
            player.setDataSource(tempAudioFile!!.absolutePath)
            player.setOnPreparedListener { it.start() }
            player.setOnCompletionListener {
                onCompletion?.invoke()
                cleanupPlayerInstance(it, "TTS playback")
            }
            player.setOnErrorListener { mp, what, extra ->
                Log.e("AudioPlayer", "MediaPlayer error for TTS audio: what=$what, extra=$extra")
                onCompletion?.invoke()
                cleanupPlayerInstance(mp, "TTS error")
                true
            }
            player.prepareAsync()
        } catch (e: Exception) {
            Log.e("AudioPlayer", "Error playing audio from generated bytes", e)
            onCompletion?.invoke()
            cleanupPlayerInstance(player, "TTS setup exception")
        }
    }

    // --- Cleanup and Helper Logic ---

    private fun cleanupPlayerInstance(player: MediaPlayer, reason: String) {
        Log.d("AudioPlayer", "Cleaning up MediaPlayer instance due to: $reason")
        try {
            // A simple way to check if the player is still valid is to catch the IllegalStateException.
            if (player.isPlaying) {
                player.stop()
            }
            player.release()
        } catch (e: IllegalStateException) {
            // This is expected if the player was already released, so we can log it as a warning.
            Log.w(
                "AudioPlayer",
                "Player was already released or in a bad state. Reason: ${e.message}"
            )
        } catch (e: Exception) {
            Log.w("AudioPlayer", "Generic exception during cleanup: ${e.message}")
        }

        // Only nullify the global variable if it's the one we're cleaning up.
        if (currentMediaPlayer == player) {
            currentMediaPlayer = null
        }

        // Clean up temp file if this was a TTS playback
        if (reason.contains("TTS")) {
            tempAudioFile?.delete()
            tempAudioFile = null
        }
    }

    private fun stopCurrentSound() {
        currentMediaPlayer?.let { playerToStop ->
            Log.d("AudioPlayer", "stopCurrentSound called. Stopping player.")
            cleanupPlayerInstance(playerToStop, "stopCurrentSound explicit call")
        }
    }

    fun release() {
        Log.d("AudioPlayer", "AudioPlayer.release() called.")
        stopCurrentSound()
    }


    // --- ONNX and WAV Generation Logic (Unchanged from original) ---

    suspend fun playFromInputIds(inputIds: List<Long>, context: Context, onCompletion: () -> Unit) {
        stopCurrentSound()
        try {
            val wavBytes = createAudioAndConvertToWav(inputIds, context)
            playAudio(context, wavBytes, onCompletion)
        } catch (e: Exception) {
            Log.e("AudioPlayer", "Error generating or playing audio from input IDs", e)
            onCompletion.invoke()
        }
    }

    suspend fun createAudioAndConvertToWav(inputIds: List<Long>, context: Context): ByteArray {
        return withContext(Dispatchers.IO) {
            val session = OnnxRuntimeManager.getSession()
            val (audioFloatArray, sampleRate) = createAudio(
                tokens = inputIds.toLongArray(),
                voice = "bf_alice",
                speed = 0.7f,
                session = session,
                context = context
            )
            convertFloatArrayToWavByteArray(audioFloatArray, sampleRate)
        }
    }

    private fun convertFloatArrayToWavByteArray(audioData: FloatArray, sampleRate: Int): ByteArray {
        val header = createWavHeader(audioData.size, sampleRate)
        val pcmByteBuffer = ByteBuffer.allocate(audioData.size * 2).apply {
            order(ByteOrder.LITTLE_ENDIAN)
            asShortBuffer().let { shortBuffer ->
                for (sample in audioData) {
                    val clampedSample = sample.coerceIn(-1.0f, 1.0f)
                    val pcmValue = (clampedSample * Short.MAX_VALUE).toInt().toShort()
                    shortBuffer.put(pcmValue)
                }
            }
        }
        return ByteArray(header.size + pcmByteBuffer.array().size).also { wavBytes ->
            System.arraycopy(header, 0, wavBytes, 0, header.size)
            System.arraycopy(
                pcmByteBuffer.array(),
                0,
                wavBytes,
                header.size,
                pcmByteBuffer.array().size
            )
        }
    }

    fun createAudio(
        tokens: LongArray, voice: String, speed: Float, session: OrtSession, context: Context
    ): Pair<FloatArray, Int> {
        val SAMPLE_RATE = 22050

        if (tokens.isEmpty()) throw IllegalArgumentException("Input tokens array cannot be empty.")

        val styleLoader = StyleLoader(context)
        val styleArray = styleLoader.getStyleArray(name = voice, index = 0)
        val tokenTensor = OnnxTensor.createTensor(OrtEnvironment.getEnvironment(), arrayOf(tokens))
        val styleTensor = OnnxTensor.createTensor(OrtEnvironment.getEnvironment(), styleArray)
        val speedTensor =
            OnnxTensor.createTensor(OrtEnvironment.getEnvironment(), floatArrayOf(speed))

        val inputs = mapOf(
            "input_ids" to tokenTensor, "style" to styleTensor, "speed" to speedTensor
        )

        try {
            session.run(inputs).use { results ->
                val audioOutputTensor = results[0]
                val audioFloatArray = when (val value = audioOutputTensor.value) {
                    is Array<*> -> (value as Array<FloatArray>)[0]
                    is FloatArray -> value
                    else -> throw IllegalStateException("Unexpected audio tensor output type: ${value?.javaClass?.name}")
                }
                return Pair(audioFloatArray, SAMPLE_RATE)
            }
        } catch (e: Exception) {
            Log.e("AudioPlayer", "ONNX inference error: ${e.message}", e)
            throw e
        } finally {
            tokenTensor.close()
            styleTensor.close()
            speedTensor.close()
        }
    }

    private fun createWavHeader(dataSize: Int, sampleRate: Int): ByteArray {
        val header = ByteArray(44)
        val totalDataSize = dataSize * 2 + 36
        val numChannels = 1
        val bitsPerSample = 16
        val bytesPerSample = bitsPerSample / 8
        val byteRate = sampleRate * numChannels * bytesPerSample

        header[0] = 'R'.code.toByte(); header[1] = 'I'.code.toByte(); header[2] =
            'F'.code.toByte(); header[3] = 'F'.code.toByte()
        header[4] = (totalDataSize and 0xff).toByte()
        header[5] = (totalDataSize shr 8 and 0xff).toByte()
        header[6] = (totalDataSize shr 16 and 0xff).toByte()
        header[7] = (totalDataSize shr 24 and 0xff).toByte()
        header[8] = 'W'.code.toByte(); header[9] = 'A'.code.toByte(); header[10] =
            'V'.code.toByte(); header[11] = 'E'.code.toByte()
        header[12] = 'f'.code.toByte(); header[13] = 'm'.code.toByte(); header[14] =
            't'.code.toByte(); header[15] = ' '.code.toByte()
        header[16] = 16; header[17] = 0; header[18] = 0; header[19] = 0
        header[20] = 1; header[21] = 0
        header[22] = numChannels.toByte(); header[23] = 0
        header[24] = (sampleRate and 0xff).toByte()
        header[25] = (sampleRate shr 8 and 0xff).toByte()
        header[26] = (sampleRate shr 16 and 0xff).toByte()
        header[27] = (sampleRate shr 24 and 0xff).toByte()
        header[28] = (byteRate and 0xff).toByte()
        header[29] = (byteRate shr 8 and 0xff).toByte()
        header[30] = (byteRate shr 16 and 0xff).toByte()
        header[31] = (byteRate shr 24 and 0xff).toByte()
        header[32] = (numChannels * bytesPerSample).toByte(); header[33] = 0
        header[34] = bitsPerSample.toByte(); header[35] = 0
        header[36] = 'd'.code.toByte(); header[37] = 'a'.code.toByte(); header[38] =
            't'.code.toByte(); header[39] = 'a'.code.toByte()
        val pcmDataSize = dataSize * bytesPerSample
        header[40] = (pcmDataSize and 0xff).toByte()
        header[41] = (pcmDataSize shr 8 and 0xff).toByte()
        header[42] = (pcmDataSize shr 16 and 0xff).toByte()
        header[43] = (pcmDataSize shr 24 and 0xff).toByte()
        return header
    }
}

package com.typosbro.multilevel.utils

import android.content.Context
import android.content.Intent
import android.net.Uri
import androidx.browser.customtabs.CustomTabsIntent

/**
 * A helper to launch a URL in a Chrome Custom Tab for a better in-app experience.
 * Falls back to a standard browser intent if an error occurs.
 */
fun openUrlInCustomTab(context: Context, url: String) {
    try {
        val builder = CustomTabsIntent.Builder()
        val customTabsIntent = builder.build()
        customTabsIntent.launchUrl(context, Uri.parse(url))
    } catch (e: Exception) {
        // Fallback to opening in the default browser if Custom Tabs fails
        val intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
        context.startActivity(intent)
    }
}
// {PATH_TO_PROJECT}/app/src/main/java/com/typosbro/multilevel/utils/WaveHelperUtils.kt

package com.typosbro.multilevel.utils


import android.app.Activity
import android.content.ContentValues
import android.content.Context
import android.os.Environment
import android.provider.MediaStore
import android.util.Log
import android.widget.Toast
import java.io.OutputStream
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

fun saveAudio(audioData: FloatArray, context: Context) {
    val sampleRate = 22050


    val timeStamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())

    val contentValues = ContentValues().apply {
        put(MediaStore.MediaColumns.DISPLAY_NAME, "KOKORO_$timeStamp.wav")
        put(MediaStore.MediaColumns.MIME_TYPE, "audio/wav")
        put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_MUSIC)
    }


    val header = createWavHeader(audioData.size, sampleRate)


    val byteBuffer = ByteBuffer.allocate(audioData.size * 2)
    byteBuffer.order(ByteOrder.LITTLE_ENDIAN)
    val shortBuffer = byteBuffer.asShortBuffer()

    for (sample in audioData) {
        val pcmValue = (sample * Short.MAX_VALUE).toInt().toShort()
        shortBuffer.put(pcmValue)
    }

    val resolver = context.contentResolver
    val uri = resolver.insert(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, contentValues)

    uri?.let {
        try {
            resolver.openOutputStream(it)?.use { outputStream: OutputStream ->

                outputStream.write(header)

                outputStream.write(byteBuffer.array())
            }
            Log.d("Kokoro", "Audio saved to: $uri")
            (context as? Activity)?.runOnUiThread {
                Toast.makeText(context, "Audio saved to Music directory", Toast.LENGTH_LONG).show()
            }
        } catch (e: Exception) {
            Log.e("Kokoro", "Error saving audio: ${e.message}")
            (context as? Activity)?.runOnUiThread {
                Toast.makeText(context, "Error saving audio", Toast.LENGTH_LONG).show()
            }
        }
    } ?: run {
        Log.e("Kokoro", "Failed to create audio file")
        (context as? Activity)?.runOnUiThread {
            Toast.makeText(context, "Failed to create audio file", Toast.LENGTH_LONG).show()
        }
    }
}

private fun createWavHeader(dataSize: Int, sampleRate: Int): ByteArray {
    val header = ByteArray(44)
    val totalDataSize = dataSize * 2 + 36
    val byteRate = sampleRate * 2


    header[0] = 'R'.code.toByte()
    header[1] = 'I'.code.toByte()
    header[2] = 'F'.code.toByte()
    header[3] = 'F'.code.toByte()


    header[4] = (totalDataSize and 0xff).toByte()
    header[5] = (totalDataSize shr 8 and 0xff).toByte()
    header[6] = (totalDataSize shr 16 and 0xff).toByte()
    header[7] = (totalDataSize shr 24 and 0xff).toByte()


    header[8] = 'W'.code.toByte()
    header[9] = 'A'.code.toByte()
    header[10] = 'V'.code.toByte()
    header[11] = 'E'.code.toByte()


    header[12] = 'f'.code.toByte()
    header[13] = 'm'.code.toByte()
    header[14] = 't'.code.toByte()
    header[15] = ' '.code.toByte()


    header[16] = 16
    header[17] = 0
    header[18] = 0
    header[19] = 0


    header[20] = 1
    header[21] = 0


    header[22] = 1
    header[23] = 0


    header[24] = (sampleRate and 0xff).toByte()
    header[25] = (sampleRate shr 8 and 0xff).toByte()
    header[26] = (sampleRate shr 16 and 0xff).toByte()
    header[27] = (sampleRate shr 24 and 0xff).toByte()


    header[28] = (byteRate and 0xff).toByte()
    header[29] = (byteRate shr 8 and 0xff).toByte()
    header[30] = (byteRate shr 16 and 0xff).toByte()
    header[31] = (byteRate shr 24 and 0xff).toByte()


    header[32] = 2
    header[33] = 0


    header[34] = 16
    header[35] = 0


    header[36] = 'd'.code.toByte()
    header[37] = 'a'.code.toByte()
    header[38] = 't'.code.toByte()
    header[39] = 'a'.code.toByte()


    header[40] = (dataSize * 2 and 0xff).toByte()
    header[41] = (dataSize * 2 shr 8 and 0xff).toByte()
    header[42] = (dataSize * 2 shr 16 and 0xff).toByte()
    header[43] = (dataSize * 2 shr 24 and 0xff).toByte()

    return header
}

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.INTERNET" />

    <application
        android:name=".di.MultilevelApplication"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:enableOnBackInvokedCallback="true"
        android:exported="true"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:launchMode="singleTask"
        android:localeConfig="@xml/locales_config"
        android:networkSecurityConfig="@xml/network_security_config"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.Multilevel"
        tools:targetApi="33">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:theme="@style/Theme.Multilevel">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <!-- Define your custom scheme and host -->
                <data
                    android:host="login"
                    android:scheme="multilevelapp" />
            </intent-filter>
        </activity>

    </application>
</manifest>