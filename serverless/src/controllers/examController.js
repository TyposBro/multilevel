// {PATH_TO_PROJECT}/src/controllers/examController.js

import { db } from "../db/d1-client.js";
import { generateText, safeJsonParse } from "../utils/gemini.js";
import OFFERINGS from "../config/offerings.js";
import { partAnalysisConfig } from "../config/partAnalysis.js";

// Helper function to check if daily usage counters need to be reset.
// It returns an object with the current count and last reset date.
const resetDailyUsageIfNeeded = (count, lastReset) => {
  if (!lastReset) {
    return { count: 0, lastReset: new Date().toISOString() };
  }

  const now = new Date();
  const lastResetDate = new Date(lastReset);

  // Compare dates in UTC to avoid timezone issues
  if (
    lastResetDate.getUTCFullYear() !== now.getUTCFullYear() ||
    lastResetDate.getUTCMonth() !== now.getUTCMonth() ||
    lastResetDate.getUTCDate() !== now.getUTCDate()
  ) {
    return { count: 0, lastReset: now.toISOString() };
  }

  return { count: count || 0, lastReset };
};

/**
 * @desc    Generate a new complete multilevel exam from content in the database.
 * @route   GET /api/exam/multilevel/new
 * @access  Private
 */
export const generateNewExam = async (c) => {
  try {
    const p1_1_Promise = db.getRandomContent(c.env.DB, "content_part1_1", 3);
    const p1_2_Promise = db.getRandomContent(c.env.DB, "content_part1_2", 1);
    const p2_Promise = db.getRandomContent(c.env.DB, "content_part2", 1);
    const p3_Promise = db.getRandomContent(c.env.DB, "content_part3", 1);

    const [part1_1, part1_2_arr, part2_arr, part3_arr] = await Promise.all([
      p1_1_Promise,
      p1_2_Promise,
      p2_Promise,
      p3_Promise,
    ]);

    if (
      part1_1.length < 3 ||
      part1_2_arr.length < 1 ||
      part2_arr.length < 1 ||
      part3_arr.length < 1
    ) {
      return c.json({ message: "Could not assemble a full exam. Not enough content in DB." }, 500);
    }

    // Return the exam structure with single objects instead of arrays for single-item parts.
    return c.json({
      part1_1,
      part1_2: part1_2_arr[0],
      part2: part2_arr[0],
      part3: part3_arr[0],
    });
  } catch (error) {
    console.error("Error generating new multilevel exam:", error);
    return c.json({ message: "Server error while generating exam." }, 500);
  }
};

/**
 * @desc    Analyze a full or partial multilevel exam transcript and save the result.
 * @route   POST /api/exam/multilevel/analyze
 * @access  Private
 */
export const analyzeExam = async (c) => {
  try {
    const user = c.get("user"); // Attached by `protect` and `checkSubscriptionStatus` middleware
    const { transcript, examContent, practicePart } = await c.req.json();
    const isSinglePartPractice = !!practicePart && practicePart !== "FULL";

    if (!transcript || transcript.length === 0) {
      return c.json({ message: "Transcript is required for analysis." }, 400);
    }

    // --- TIER & USAGE CHECK LOGIC ---
    const tier = user.subscription_tier;
    const limits = OFFERINGS[tier];

    // Only enforce free tier limits if the environment is NOT development.
    if (c.env.ENVIRONMENT !== "development" && tier === "free") {
      const fullExamsUsage = resetDailyUsageIfNeeded(
        user.dailyUsage_fullExams_count,
        user.dailyUsage_fullExams_lastReset
      );
      const partPracticesUsage = resetDailyUsageIfNeeded(
        user.dailyUsage_partPractices_count,
        user.dailyUsage_partPractices_lastReset
      );

      if (isSinglePartPractice) {
        if (partPracticesUsage.count >= limits.dailyPartPractices) {
          return c.json(
            {
              message: `You have used all ${limits.dailyPartPractices} of your free part practices for today. Upgrade for unlimited access.`,
            },
            403
          );
        }
        partPracticesUsage.count += 1;
      } else {
        // Full Exam
        if (fullExamsUsage.count >= limits.dailyFullExams) {
          return c.json(
            {
              message: `You have used your ${limits.dailyFullExams} free full mock exam for today. Upgrade for more.`,
            },
            403
          );
        }
        fullExamsUsage.count += 1;
      }

      // Update the usage counters in the database
      await db.updateUserUsage(c.env.DB, user.id, {
        fullExams: fullExamsUsage,
        partPractices: partPracticesUsage,
      });
    }

    const formattedTranscript = transcript.map((t) => `${t.speaker}: ${t.text}`).join("\n");
    let prompt;

    // --- START OF PROMPT OPTIMIZATION ---
    const sttAwarenessPrompt = `
    CONTEXT: The following transcript was generated by an automated speech-to-text (STT) engine. The user is a non-native English speaker from Uzbekistan. Your primary task is to assess the user's spoken English ability, NOT the quality of the transcription.
    
    THEREFORE, YOU MUST:
    1. Infer the user's intended meaning. Be lenient with spelling, grammatical errors, or awkward phrasing that are likely STT artifacts (e.g., misheard words, homophones like 'their' vs 'there').
    2. Base your assessment on the substance of the response: vocabulary range, sentence structure complexity, coherence, and relevance to the question.
    3. If a portion of the transcript is completely nonsensical, acknowledge it as a likely STT failure and evaluate the parts of the response that are clear.
    `;
    // --- END OF PROMPT OPTIMIZATION ---

    if (isSinglePartPractice && partAnalysisConfig[practicePart]) {
      const config = partAnalysisConfig[practicePart];
      prompt = `
        You are an expert examiner for a structured, multilevel English speaking test.
        The user is practicing a single part of the exam: ${config.partName}. The maximum score for this part is ${config.maxScore}.
        ${sttAwarenessPrompt}
        Analyze the following speaking test transcript.
        TRANSCRIPT:\n---\n${formattedTranscript}\n---\n
        CRITICAL: Your entire response must be ONLY a single, valid JSON object using this exact structure, with no extra text or explanations.
        { "part": "${config.partName}", "score": <number>, "feedback": "${config.promptFocus}" }`;
    } else {
      prompt = `
        You are an expert examiner for a structured, multilevel English speaking test. The maximum score is 72.
        ${sttAwarenessPrompt}
        The exam has 4 parts:
        - Part 1.1: 3 personal questions (${partAnalysisConfig.P1_1.maxScore} points total)
        - Part 1.2: Picture comparison (${partAnalysisConfig.P1_2.maxScore} points total)
        - Part 2: Single picture monologue (${partAnalysisConfig.P2.maxScore} points total)
        - Part 3: Argumentative monologue (${partAnalysisConfig.P3.maxScore} points total)
        Based on the transcript, provide a score and constructive feedback for each part. Calculate the final total score (out of 72).
        TRANSCRIPT:\n---\n${formattedTranscript}\n---\n
        CRITICAL: Your entire response must be ONLY a single, valid JSON object using this exact structure, with no extra text or explanations.
        { "totalScore": <number>, "feedbackBreakdown": [
          { "part": "Part 1.1", "score": <number>, "feedback": "${partAnalysisConfig.P1_1.promptFocus}" },
          { "part": "Part 1.2", "score": <number>, "feedback": "${partAnalysisConfig.P1_2.promptFocus}" },
          { "part": "Part 2", "score": <number>, "feedback": "${partAnalysisConfig.P2.promptFocus}" },
          { "part": "Part 3", "score": <number>, "feedback": "${partAnalysisConfig.P3.promptFocus}" }
        ]}`;
    }

    const responseText = await generateText(c, prompt);
    const analysisData = safeJsonParse(responseText);

    let totalScore;
    let feedbackBreakdown;

    if (isSinglePartPractice) {
      if (!analysisData || typeof analysisData.score === "undefined" || !analysisData.feedback) {
        throw new Error("AI failed to generate a valid single-part analysis JSON.");
      }
      totalScore = analysisData.score;
      feedbackBreakdown = [analysisData];
    } else {
      if (
        !analysisData ||
        typeof analysisData.totalScore === "undefined" ||
        !analysisData.feedbackBreakdown
      ) {
        throw new Error("AI failed to generate a valid full-exam analysis JSON.");
      }
      totalScore = analysisData.totalScore;
      feedbackBreakdown = analysisData.feedbackBreakdown;
    }

    const resultResponse = {
      _id: crypto.randomUUID(),
      userId: user.id,
      totalScore,
      feedbackBreakdown,
      transcript,
      createdAt: new Date().toISOString(),
    };

    return c.json(resultResponse, 201);
  } catch (error) {
    console.error("Error during multilevel exam analysis:", error);
    return c.json({ message: error.message || "Server error during exam analysis." }, 500);
  }
};
